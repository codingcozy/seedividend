---
title: "Next JS 렌더링 패턴 - 포괄적인 안내"
description: ""
coverImage: "/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png"
date: 2024-05-14 12:43
ogImage: 
  url: /assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png
tag: Tech
originalTitle: "Next JS Rendering Patterns — a Comprehensive Guide"
link: "https://medium.com/javascript-in-plain-english/next-js-rendering-patterns-a-comprehensive-guide-e20a092f0f21"
isUpdated: true
---




렌더링 패턴에 대한 정보는 문서, 자습서 또는 블로그 게시물 등이 끊임없이 있습니다. 그러나 시작하고 무언가를 구축하기 위해 얼마나 많은 지식이 필요할까요? 이 게시물에서는 무엇이 무엇인지 이해하고 렌더링이 Next.js에서 어떻게 작동하는지를 굳게 이해하는 데 도움이 되는 각기 다른 렌더링 패턴의 기본 내용을 요약하겠습니다.

![image](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_0.png)

- 두 가지 주요 렌더링 패턴
  - 클라이언트 측 렌더링
    - 어떻게 작동합니까?
    - 브라우저에서 구성 요소를 렌더링하는 방법?
    - 데이터 가져오기:
    - 이점:
    - 제한 사항:
  - SSG — 정적 사이트 생성
    - 어떻게 작동합니까?
    - 언제 사용해야 하나요?
    - Next 13부터 페이지를 완전 정적으로 만들기:
    - 동적 경로 생성 및 빌드 시간에 데이터 가져오기:
    - 이점:
    - 제한 사항:
  - SSR — 서버 측 렌더링
    - 어떻게 작동합니까?
    - 유의할 사항:
    - 페이지를 완전히 동적으로 만드는 방법:
    - 이점:
    - 제한 사항:
  - ISR — 점진적 사이트 재생
    - 어떻게 작동합니까?
    - 이점:
  - PPR — 부분 사전 렌더링:
    - 부분 사전 렌더링 활성화:
    - 필요성:
    - 어떻게 작동합니까?
- 기본 Next.js 렌더링 동작
- 렌더링 위치 결정 방식

# 두 가지 주요 렌더링 패턴



위의 텍스트를 친근한 톤으로 한국어로 번역해 드립니다.

다음과 같이 렌더링 패턴을 넓게 분류할 수 있어요:

- 클라이언트 측 렌더링
- 사전 렌더링

이름에서 알 수 있듯이 클라이언트 측 렌더링은 브라우저에서 구성 요소를 렌더링하는 것을 말해요.

사전 렌더링은 다양한 방법으로 수행될 수 있어요.



- SSG 또는 정적 사이트 재생성
- SSR 또는 서버 사이드 렌더링
- ISR 또는 증분 사이트 재생성
- PPR 또는 부분 사전 렌더링 (Next 14에서 실험적 기능으로 제공됨)

우리는 클라이언트 측 렌더링부터 시작해서 다양한 사전 렌더링 접근법으로 넘어갈 것입니다.

# 클라이언트 측 렌더링

## 어떻게 작동하나요?



Next JS에서 클라이언트 구성 요소는 초기에 서버에서 사전 렌더링되고 DOM이 클라이언트로 전송되어 사용자가 볼 수 있는 내용이 제공됩니다. 그런 다음 JS 코드가 브라우저로 전송되어 DOM에 상호 작용을 추가합니다. DOM이 표시된 후 상호 작용을 천천히 추가하는 이 프로세스를 수분화(hydration)라고 합니다.

## 브라우저에서 구성 요소를 렌더링하는 방법은 무엇인가요?

파일의 시작 부분에 "use client" 지시문을 추가하면 됩니다.

## 데이터 가져오기:



Next JS 백엔드로 API 호출하거나 필요한 데이터를 가져오기 위해 외부 엔드포인트로 API 호출할 수 있어요.

또는 Next JS 서버 컴포넌트에 정규 함수 호출을 할 수도 있어요.

만약 백엔드도 Next JS로 작성되었다면 데이터베이스 액세스를 그 자체에서 수행할 수 있어요.

## 혜택:



- 페이지에 상호 작용성을 제공하기 위해 코드에 이벤트 리스너를 추가할 수 있어요.
- 상태를 유지하고 라이프사이클의 다른 단계에서 특정 작업을 수행하거나 상태를 위한 중앙 저장소를 사용하는 훅을 사용할 수 있어요.

## 제한 사항:

- 콘텐츠 표시에 지연이 있을 수 있어요. JavaScript를 구문 분석한 후 HTML을 얻기 전에 사용자가 보여지는 내용에 대한 지연 때문이에요. 브라우저에서 렌더링 작업을 수행하는 동안 사용자가 빈 페이지를 보거나 상호 작용할 수 없는 페이지를 보게 될 수 있어요. 이는 JS 크기, 코드 내 존재하는 차단 작업(있는 경우), 사용자 디바이스의 제약 사항(인터넷 연결, 메모리 가용성)에 따라 다양합니다.
- SEO 크롤러는 DOM 탐색을 통해 콘텐츠를 사용해 페이지를 색인화해요. JS가 로드되기를 기다려야 할 때 그들은 DOM을 스캔하기 전에 효과적으로 페이지를 색인화할 수 없어요.

# SSG — 정적 사이트 생성



## 어떻게 작동하나요?

이 경우의 HTML은 빌드 시간에 생성되어 CDN(콘텐츠 전송 네트워크)에 저장되며, 사용자가 웹사이트/특정 경로에 접속할 때 캐시된 페이지의 버전을 제공합니다.

## 언제 사용해야 하나요?

만약 귀하의 웹사이트에 내용이 거의 변경되지 않고 한 번 오랜 기간에 한 번 변경을 계획하고 예약할 수 있다면, 빌드 시간에 해당 내용을 생성하는 것이 가장 좋습니다(서버에서 생성하지 않습니다).



FAQ 페이지는 정적으로 생성될 수 있습니다. 회사 소개 페이지, 문서 페이지도 자주 다시 생성할 필요가 없으며 빌드 시간에 생성할 수 있습니다.

## Next 13부터 페이지를 완전 정적으로 만드는 방법:

페이지를 완전 정적으로 만들려면 (다시 말해, Next가 서버에서 렌더링할지 빌드 시간에 렌더링할지 결정하지 않고 우리가 스스로 결정하는 것), 관련 파일에서 동적 구성을 값이 force-static으로 내보냅니다:

```js
export const dynamic = 'force-static';
```



## 동적 경로 생성 및 데이터 빌드 시간에 가져오기:

이를 위해 generateStaticParams 메서드를 사용할 수 있습니다.

이 블로그에서는 앱 라우터의 generateStaticParams가 페이지 라우터의 getStaticProps 및 getStaticPaths의 기능을 대체하는 방법에 대한 깔끔한 설명을 제공합니다.

## 혜택:



- 페이지의 내용이 자주 변경되지 않는 많은 페이지가 있다면, 서버에서 매번 미리 렌더링하는 것은 서버 부하를 늘립니다. 정적으로 생성하고 CDN에 저장하면 서버로부터 이 부하를 덜 수행할 수 있습니다.
- 페이지 로드 시 콘텐츠가 즉시 제공되면 SEO 순위가 높아질 가능성이 높아집니다.

## 제한 사항:

- 데이터가 자주 업데이트되는 정적으로 생성된 페이지가 필요한 경우, 사용자에게 제공될 때 데이터가 오래되어 버릴 가능성이 있습니다.
- 대량의 정적으로 생성된 페이지의 경우, 빌드 시간이 더 오래 걸릴 수 있습니다.

# SSR — 서버 측 렌더링



이를 동적 렌더링이라고도 합니다.

지시문이나 "서버 사용" 지시문이 없는 파일에서, 서버에서 초기 페이지 로드 후에는 클라이언트가 서버에 요청을 보낼 때 연속적으로 서버 측 렌더링이 발생합니다. 이 요청은 캐싱을 비활성화하거나 재검증된 데이터를 가져오는 형태로 발생할 수 있습니다. 페이지가 사용자나 클라이언트 측의 특정 변경 사항에 기반하여 다시 생성되어야 하기 때문에 이를 동적이라고 합니다.

## 작동 방식은?

HTML이 서버에 로드되고, JS 기능도 서버에 남아 있습니다. 그런 다음 HTML이 클라이언트로 전송되어 표시됩니다.



## 알림:

- 서버 구성 요소의 JavaScript는 서버에서 실행되며 클라이언트로 전달되지 않습니다. 이러한 구성 요소에 대해서는 브라우저에서 하이드레이션이 없습니다.
- 서버 구성 요소 내에서는 개인 API 키를 안전하게 사용할 수 있습니다. 클라이언트에 노출되지 않기 때문입니다.
- 서버 구성 요소 내에서 Node.js 코드를 작성할 수 있습니다. 예시: 파일 읽기/쓰기 코드.

## 페이지를 완전히 동적으로 만들려면:

```js
export const dynamic = "force-dynamic";
```



## 장점:

- 사전 렌더링된 DOM은 검색 엔진에서 크롤링 및 색인화하기 쉽습니다.
- 데이터 액세스를 할 수 있으며, 가져온 데이터는 즉시 사용하여 DOM을 작성할 수 있습니다 (사용자 세부정보 표시) 브라우저로 HTML을 전송하기 전에. 백엔드에 대한 api 호출을 하는 데 추가적인 시간이 필요하지 않습니다.
- 데이터는 일정 간격으로 재유효성 검사될 수 있어 항상 최신 상태로 유지할 수 있습니다.
- 브라우저는 컴포넌트를 렌더링하는 데 일을 하지 않아 클라이언트 측의 제약 사항인 네트워크 연결 부실, 메모리 부족 등이 페이지로드를 방해하지 않습니다.

## 한계:

- 서버 렌더링된 컴포넌트는 대화형이 아니며, 대화형은 이벤트 핸들러의 사용을 필요로 하며 이것은 브라우저에서만 가능합니다. 해결책으로는: 서버에서 정적 내용을 렌더링하고 대화형 내용을 클라이언트에 리프 컴포넌트로 렌더링할 수 있습니다. 예를 들어, 서버에서 렌더링된 내용이 풍부한 페이지 내에 클라이언트에서 렌더링된 양식 또는 버튼이 있는 것과 같습니다.
- 서버 컴포넌트에는 마운팅/언마운팅 애니메이션을 사용할 수 없습니다. 이러한 애니메이션에 대해 React 훅을 사용하려면 컴포넌트가 마운트된 시점과 React 훅을 알아야 하는데 서버에서는 React 훅을 사용할 수 없습니다.
- 서버 컴포넌트에서 브라우저 API인 웹 저장소 API (로컬저장소 및 세션저장소), WebRTC (웹 실시간 통신 API), Geolocation API (사용자의 위도 및 경도 가져오기)와 같은 브라우저 API를 사용할 수 없습니다.



# ISR — 증분 사이트 재생성

## 어떻게 작동하나요?

페이지는 빌드 시에 데이터베이스에서 가져온 데이터로 정적으로 생성됩니다. 그러나 fetch 메서드 자체에서 페이지가 다시 생성될 시간 간격을 지정하고 최신 데이터를 가져와 재확인할 수 있습니다. 이 재확인은 서버에서 동적으로 발생합니다.

```js
// `app` 디렉토리
async function getPosts() {
  const res = await fetch(`https://.../posts`, 
  { next: { revalidate: 60 } });
  const data = await res.json();
 
  return data.posts;
}
 
export default async function PostList() {
  const posts = await getPosts();
 
  return posts.map((post) => <div>{post.name}</div>);
}
```



fetch 메서드는 값으로 60을 갖는 revalidate 속성을 지정합니다. 따라서 페이지는 매 60초마다 데이터를 다시 가져와 새 데이터로 다시 생성됩니다.

fetch를 사용하지 않을 때 revalidate하는 방법: axios나 Prisma와 같은 ORM을 사용하는 경우 원하는 시간 간격으로 revalidate 구성을 내보내세요:

```js
export const revalidate = 3600 // 최대 1시간마다 revalidate
```

## 혜택:



더 빠른 로드 시간과 업데이트된 데이터로 정적 생성의 SEO 성능을 얻을 수 있어요. 

# PPR — 부분 사전 렌더링:

이건 실험적인 기능이에요.

## 부분 사전 렌더링 ( PPR )을 활성화하려면:



최신 Next canary 버전을 설치해보세요:

```js
npm install next@cannary
```

혹은,

```js
npx create-next-app@latest .
```



프로젝트를 시작한 후, next.config.js 파일로 이동해서 다음과 같이 추가해주세요:

```js
experimental: {
 ppr: true
}
```

## 이것이 필요한 이유:

Next 14 이전에는 전체 경로가 정적 또는 동적 중 하나여야 했습니다. 그러나 실제 요구사항은 몇 가지 요소가 동적으로 업데이트되어야 하는 정적 페이지일 수 있습니다.
예를들어, 제품 상세 페이지의 경우 다음이 빌드 시간에 생성된 정적 컨텐츠로 문제없이 표시될 수 있습니다:
1. 제품 이름
2. 제품 설명
3. 제품 가격 (가격이 업데이트될 수 있도록 재검증)
4. 기타 제품 정보



그리고 일부 내용들은 동적으로 생성되어야 합니다 (사용자 요청에 기반하여 서버에서 생성됨):
1. 총 평가 및 리뷰 수
2. 제품 평점
3. 리뷰 섹션

## 작동 방식은?

따라서 정적 로딩 셸에 전체 제품 세부 정보 경로를 렌더링하고 그 안에 평가 수, 리뷰 수, 리뷰 섹션을 동적으로 만들 수 있습니다.

![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_1.png)



동적 콘텐츠는 비동기로 병렬로 스트림 처리되어 서로의 로딩 시간을 차단하지 않습니다.

PPR이 활성화되면 사용자 지정 클라이언트 지시문이 표시되지 않은 모든 사전 렌더링된 페이지 (예:, 허용될 것입니다. 즉, 컴포넌트는 정적으로 생성된 로딩 쉘 내에서 렌더링될 것입니다.
그런 다음 동적 컴포넌트를 React Suspense 경계 내로 래핑할 수 있습니다.
그래서 중첩된 제품 세부 정보 라우트는 제품 이미지, 제품 설명, 제품 이름, 가격과 같이 모든 것이 정적으로 생성되고 리뷰, 리뷰 수, 평점 등은 적절한 후행 컴포넌트와 함께 Suspense로 래핑될 것입니다.
코드가 이러한 Suspense로 래핑된 컴포넌트를 만나면 제공된 후행 컴포넌트를 가져와 그것들을 정적으로 생성하고 해당 컴포넌트의 데이터가 사용 가능할 때까지 래핑된 컴포넌트의 생성을 일시 중단할 것입니다.
이러한 모든 Suspense로 래핑된 컴포넌트는 비동기로 되어 있으며 데이터를 병렬로 가져오며 한 컴포넌트의 데이터가 사용 가능해지면 렌더링될 것입니다.

```js
return (
 <div>
  <A/>
  <B/>
  <Suspense fallback={<FallbackC/>}>
   <C data={fetch async data}/>
  </Suspense>
  <D/>
  <Suspense fallback={<FallbackE/>}>
   <E data={fetch async data}/>
  </Suspense>
  <F/>
 </div>
)
```

여기서 A, B, FallbackC, D, FallbackE 및 F 컴포넌트는 빌드 시 정적으로 생성됩니다.
사용자가 라우트를 요청하면 정적 컴포넌트가 즉시 사용 가능합니다. 동시에 C 및 E에 대한 데이터 가져오기가 병렬로 시작됩니다. 먼저 데이터를 받는 컴포넌트가 먼저 나타납니다.



PPR에 대한 자세한 이해를 위해 이 블로그를 읽어보세요.

## Next.js 기본 렌더링 동작

기본적으로 Next JS는 정적 사이트 생성을 선택하려고 노력합니다. 따라서 동적 변수의 값은 자동으로 설정됩니다. 여 less 향을 변경하지 않는 한 Next는 모든 것을 캐시하려고 할 것입니다.

의도적으로 동적 렌더링(서버 상에서)을 선택하기 위해 다음 중 하나를 수행해야 합니다:



- 값이 'force-dynamic'인 동적 변수를 내보내세요.
- 'generateStaticParams'를 사용하지 않고 '[id]'와 같은 동적 경로 이름을 사용하세요.
- 값이 0으로 설정된 revalidate 구성을 내보내세요.

```js
export const revalidate = 0;
```

4. cookies() 또는 header()와 같은 동적 함수를 사용하세요.

5. fetch 요청을 생성하고 'cache: ‘no-store’ ' 또는 'next: 'revalidate: 0'을 전달하세요.



# 렌더링 위치는 어떻게 결정되나요

이미 "use client" 및 "use server" 지시문이 구성 요소를 각각 클라이언트와 서버에 렌더링하도록 표시하는 데 사용된다는 것을 알고 계실 것입니다. 그러나 이러한 지시문들이 실제로 어떻게 해석되는지 궁금하시죠?

파일 상단에 "use client"를 추가하면 이 파일에 만들어진 구성 요소뿐만 아니라 해당 파일이 의존하는 모든 구성 요소가 브라우저에서 렌더링됩니다. "use client"로 표시된 파일의 종속성은 해당 파일의 모든 import 문을 확인하여 해결됩니다.

![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_2.png)



상기 시나리오를 고려해보세요. 당신은 "home"이 브라우저에 렌더링되며, "testimonials"은 서버에 렌더링되도록 지정했습니다. 그러나 서버 구성 요소가 먼저 로드되고, 그 다음 클라이언트 구성 요소가 로드됩니다. 당신은 Next.js에게 Home 구성 요소가 클라이언트 측에 로드되기 전에 Testimonials를 서버에 렌더링하기 전에 기다리도록 요청했습니다. 하지만 Testimonials 구성 요소 중 하나인 의존성이 아직 렌더링되지 않았을 때 Next.js가 어떻게 Home 구성 요소를 클라이언트 측에 렌더링할 수 있을까요?

이 문제를 해결하기 위해, 서버 구성 요소로 지정되었음에도 불구하고 Testimonials 구성 요소는 클라이언트 측에서 로드될 것입니다.

다음을 해결하기 위해:

Home 구성 요소에서 렌더링하는 동안 서버에서 여전히 Testimonials를 로드하려면 Testimonials 구성 요소를 부모 서버 구성 요소로 전달하여 Home 구성 요소에 자식 속성으로 전달하고 자식으로 렌더링하십시오:




![이미지](/assets/img/2024-05-14-NextJSRenderingPatternsaComprehensiveGuide_3.png)

홈페이지(home.js)에서 Testimonials에 대한 의존성이 페이지(page.js)로 전환되었습니다. 페이지(page.js)는 또한 서버 컴포넌트입니다.

# 쉽게 설명하기 🚀

In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:




- 글을 박수로 환영하고 작가를 팔로우해 주세요 ️👏️️
- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터
- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed
- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요