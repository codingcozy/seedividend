---
title: "Docker 컨테이너 보안 간편 가이드 흔한 익스플로잇과 방어 방법"
description: ""
coverImage: "/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_0.png"
date: 2024-07-09 10:52
ogImage: 
  url: /assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_0.png
tag: Tech
originalTitle: "Simplified Docker Container Security: Common Exploits and Defenses"
link: "https://medium.com/@thehackersmeetup/simplified-docker-container-security-common-exploits-and-defenses-dea7adfca026"
---


![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_0.png)

안녕하세요! 요즘 거의 모든 가상화된 디지털 인프라의 건축 모듈은 도커 컨테이너입니다. 현재 세상은 아키텍처를 마이크로서비스로 변경하는 중이며, 이러한 테크토닉 변화를 촉진하기 위해 컨테이너와 같이 놀라운 것이 필요했습니다. 

이 문서는 도커 컨테이너와 그들의 보안 측면을 가장 복잡하지 않은 방식으로 이해하는 요약된 설명서입니다. 컴퓨팅 세계의 이 분야를 간단히 탐험하고자 하는 분들에게 이 글이 유익한 자원이 되길 바랍니다.

먼저 구조적 해부부터 시작하여 가장 흔한 보안 취약점과 이에 대한 방어책을 자세히 이해하고 이 멋진 가상화 블랙박스들을 운용하고 배포하는 데 도움이 되도록 해드리겠습니다. 이 글을 완전히 읽을 때까지만요! :)

<div class="content-ad"></div>

# Docker Containers: Architecture

도커 컨테이너 아키텍처의 기본 원리를 이해하는 것은 모든 보안 복잡성에 열쇠를 꽂을 때 필수적입니다.

컨테이너는 애플리케이션, 설정 및 관련 작동 의존성을 모두 하나의 논리적 개체로 표준화된 방식으로 패키징하는 것입니다.

가상 머신이 제공하는 것과 유사하게, 즉 공통 하드웨어 인프라 위에 작동 운영체제의 전체 하위 계층을 포괄하면서 이를 끝 사용자에게 추상화된 가상화된 운영체제로 제공하는 것과 유사하게 컨테이너는 완전히 작동하는 애플리케이션에 필요한 모든 내부 구성 요소를 포함하고 이를 단일 논리적 개체로 배포합니다.

<div class="content-ad"></div>


![이미지 1](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_1.png)

![이미지 2](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_2.png)

컨테이너는 컴퓨터에게는 독립적인 프로세스로 이해되며 실행될 때 tar볼로부터 추출되고, 이후에는 이름 공간에 고정된 채로 Cgroups으로 제어됩니다.

컨테이너는 기본적으로 이미지의 실행 중인 인스턴스입니다. 이미지는 기본적으로 핵심 응용프로그램 코드의 정적 번들입니다.


<div class="content-ad"></div>

docker와 같은 소프트웨어는 컨테이너 런타임 소프트웨어로 알려져 있어요. 따라서 이들은 본질적으로 물리적 서버에서 실행 중인지 아니면 실제 가상 머신에서 실행 중인지에 대해 신경 쓰지 않아요.

이 컨테이너 런타임의 핵심 기능은 이미지로 제공되는 연관된 애플리케이션 코드를 가져와 필요한 모든 설정, 종속성을 포함하여 이를 모두 번들링하고 패키징하며, 이를 생성하여 컨테이너로 알려진 완전히 실행 가능하고 논리적으로 독립적인 가상화된 배포를 만드는 것이에요.

이 컨테이너 런타임의 사용자는 이 프로세스를 수행하기 위해 필요한 모든 규칙과 세부사항을 지정하여 이러한 작업을 컨테이너 런타임에 의해 처리되는 명령 파일에 기입해야 해요. 

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_3.png)

<div class="content-ad"></div>

도커는 기본적으로 호스트 OS 위에 가상화 레이어를 도입하여 컨테이너화를 가능케 하는 컨테이너화 기술입니다.

하드웨어 상에 전체 운영 체제를 가상화하는 가상 머신 플랫폼과 대조적으로 호스트 OS 커널을 사용합니다.

![도커 컨테이너 보안, 취약점 및 방어책](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_4.png)

이미지를 통해 도커 컨테이너를 만들고 빌드하는 과정과 그 뒤에서 무슨 일이 일어나는지 알아보겠습니다.

<div class="content-ad"></div>

1. 도커 클라이언트는 사용자가 도커 데몬과 상호 작용하는 인터페이스로, 기본적으로 도커 엔진의 구성 요소인 도커 데몬이다.

2. 사용자들은 처음에 도커 파일이라고 알려진 명령기반 파일을 제공하는데, 이 파일은 도커 데몬이 지침에 따라 어떻게 실행 가능한 이미지, 즉 지정된 지침 원칙에 따라 컨테이너를 생성해야 하는지에 대한 모든 지침을 포함하고 있습니다.

![image](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_5.png)

3. 이제 도커 데몬은 다른 모든 도커 엔진의 핵심 구성 요소와 함께 체계적인 계층적 접근 방식을 통해 필요한 이미지를 로컬로 가져오거나 레지스트리에서 가져와 이를 기반으로 컨테이너를 더 구축합니다.

<div class="content-ad"></div>

4. 도커 데몬과 도커 클라이언트 간의 내부 통신은 일반적으로 도커.sock라고도 불리는 TCP(Unix) 소켓을 통해 이루어집니다. (포트 2375)

5. 도커 CLI에는 빌드, 풀링, 실행 및 결과 컨테이너 관리를 위한 다양한 명령어가 포함되어 있습니다. 아래 그림에서 간단한 예제를 확인할 수 있습니다.

![도커 CLI 명령 예제](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_6.png)

도커가 컨테이너화를 어떻게 구현하는지, 도커 컨테이너의 구조를 이해하는 방법:

<div class="content-ad"></div>

관찰하는 컨테이너들은 기본적으로 적절한 리소스를 패키징하여 격리 및 추상화를 실현한 결과물이며, 이는 Linux 커널의 두 가지 기능인 Control Groups (cgroups)와 네임스페이스를 활용하여 가능해집니다. 따라서 우리는 컨테이너를 네임스페이스에 기반을 둔 것으로 정의하며, cgroups로 제어됩니다.

본질적으로 컨테이너는 리소스 접근에 제한이 있는 격리층 위에 있는 일반 CPU 프로세스일 뿐입니다.

네임스페이스와 도커 컨테이너:

Linux 커널에서 실행 중인 각 프로세스는 기본적으로 특정한 네임스페이스와 연관되어 있으며, 그러므로 해당 네임스페이스와 하위 네임스페이스와 연관된 리소스만 볼 수 있고 활용할 수 있습니다.

<div class="content-ad"></div>

네임스페이스는 컨테이너 격리의 핵심 역할을 하는데, 이를 통해 운영 체제가 프로세스가 볼 수 있는 것을 제한할 수 있습니다. 다른 병렬 프로세스, 파일 시스템 등이 이에 해당합니다.

도커 컨테이너에서의 핵심 역할은 컨테이너와 호스트 간의 완전한 격리를 제공하는 것입니다.

리눅스 커널에서 유래한 도커 컨테이너는 컴퓨팅 리소스의 모든 측면을 제어하는 6 가지 유형의 네임스페이스를 활용합니다. PID, NET, IPC, MNT, UTS, UID와 같은 것들입니다. 이들은 프로세스 ID, 네트워크 등과 같은 리소스를 위한 것입니다.

도커 컨테이너 내에서 권한 격리를 구현하기 위해 일반적으로 사용되는 사용자 네임스페이스를 다루는 작은 예제를 통해 네임스페이스가 어떻게 작동하는지 이해할 수 있습니다.

<div class="content-ad"></div>

일반 컨테이너 빌드가 어떻게 베이스 이미지에서 여러 레이어를 풀하면서 dockerfile의 지시와 설정에 따라 진행되는지 이해하는 것이 중요합니다. 그리고 해당 컨테이너를 통해 알맞은 최종 컨테이너가 생성되는 과정도 함께 살펴보겠습니다.

이전에 만든 컨테이너를 검토하고 세부정보를 이해해봅시다:

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_7.png)

이 컨테이너의 RootFS [Root 파일 시스템] 섹션을 분석하면 해당 파일 시스템에 다양한 레이어가 포함되어 있고 각 레이어의 연관된 SHA 해시가 명시되어 있는 것을 확인할 수 있습니다. 초기 이미지에서 시작된 docker build가 여러 레이어로 생성되었음을 시사하는데, 이는 관련 구성에 맞게 중간 생성되었기 때문입니다. 따라서 전용 저장소 드라이버를 통해 각 레이어가 병합되어 최종 컨테이너가 생성된 것입니다.

<div class="content-ad"></div>

이 Docker 버전은 Overlay2 유형의 스토리지 드라이버를 사용하는데, 이는 이러한 종류의 빌드 작업에 특화되어 있어 이미지 빌드 및 관리에 중요한 역할을 합니다.

이 드라이버가 사용하는 또 다른 중요한 기술은 "기록 가능 레이어 관리"라고 불리는 기술입니다.

이 기술은 매우 중요하며 컨테이너의 개발 기반으로 사용되는데, 기본적으로 컨테이너가 실행되면 변경 사항을 저장하고 관리해야하는 모든 실행 데이터를 처리하기 위해 기록 가능 레이어가 필요하며, 이 레이어를 통해 새로운 상태를 유지하면서 기본 기본 이미지를 사용하여 효율적인 리소스 활용을 촉진합니다.

Overlay2 스토리지 드라이버의 작동은 컨테이너 빌드 전체 프로세스의 핵심입니다.

<div class="content-ad"></div>

리눅스 커널 드라이버 중 하나로, 사실상 유니언 파일 시스템을 구현한 것이기도 합니다.

![이미지1](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_8.png)

![이미지2](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_9.png)

도커 컨테이너와 도커 컨테이너는 위 설명 그림에 표시된 대로 계층 구조를 기반으로 한 결과물입니다. 도커 컨테이너는 우리에게 단일 논리적 개체로 보일 수 있지만 실제로는 이미지 레이어, 컨테이너 레이어, 컨테이너 마운트로 논리적으로 삼단계로 구성되어 있으며 이는 실제로 사용하는 overlayFS의 세 가지 하부 디렉토리에 매핑됩니다.

<div class="content-ad"></div>

이 디렉토리인 "merged", "upperdir", 그리고 "lowerdir"은 각기 다른 목적을 가지고 있어요. 이미지 레이어는 기본적으로 lowerdir이고 컨테이너 레이어는 upperdir이에요. 여기서 병합된 레이어는 실제 컨테이너 마운트인 외부 컨테이너의 통합된 뷰를 제공해요. 이 병합된 디렉토리는 컨테이너 마운트 지점으로 알려져 있어요.

컨테이너를 생성하기 위해 overlay2 드라이버는 기본 이미지로부터 빌드할 때 어떤 내용을 합치는지에 따라 이러한 디렉토리의 내용을 모두 결합해요. 새로운 엔티티가 컨테이너 내용에 추가될 때에는 일반적으로 이 upperdir에서 이동됩니다. 왜냐하면 이는 쓰기 가능한 컨테이너 레이어이기 때문에 우선시 되고, 반면에 기본 이미지로부터 빌드할 때 lowerdir의 내용이 사용되어 마운트됩니다. 이 적용된 기술은 Copy-Up이라고 불리는데, 이는 전통적인 Copy-on-Write 파일 시스템과 유사한 기술이에요.

따라서, 모든 후속 쓰기 작업은 상위 레이어에서 일어납니다. 위의 설명이 이 아이디어를 명확하게보여줍니다.

다음 예제는 네임스페이스 제한이 어떻게 작동하는지 설명해요. (이 경우에는 사용자 네임스페이스)

<div class="content-ad"></div>

보통은 아래 그림과 같이 도커 컨테이너를 생성한 후, 호스트의 공유 폴더를 해당 컨테이너에 마운트해야 합니다. 그런 다음 컨테이너 내부에서 이 마운트된 폴더의 내용을 수정할 수 있는지 확인합니다.

![도커 컨테이너 보안 취약점 및 방어 간단 설명](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_10.png)

![도커 컨테이너 보안 취약점 및 방어 간단 설명](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_11.png)

![도커 컨테이너 보안 취약점 및 방어 간단 설명](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_12.png)

<div class="content-ad"></div>

특정 행동이 허용되는 것으로 분명하게 관찰되었지만, 이는 대부분의 상황에서 큰 위협을 야기할 수 있습니다. 공격자들이 때로는 이 권한을 악용할 수 있기 때문입니다. 이제 [- -userns-remap=default] 즉, 사용자 네임스페이스 플래그를 통해 이 작업을 제한할 수 있습니다. 여기에는 여전히 마운트가 컨테이너에 명확히 표시되지만, 프로세스인 즉, 컨테이너가 이 마운트에서 격리되고 별도의 사용자 네임스페이스를 활성화해야 합니다. 이를 구현함으로써 도커 데몬에 의해 특권 작업이 허용되지 않습니다.

![2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_13.png](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_13.png)

마찬가지로, userns는 사용자와 그룹의 시각을 컨테이너로 격리하는 방법을 제공하며, 모든 네임스페이스 구조는 특정 리소스 격리를 허용하기 위해 컨테이너에 의해 사용됩니다.

<div class="content-ad"></div>

도커 컨테이너와 Cgroups:

Cgroups는 리눅스 커널의 기본 기능으로, 프로세스의 자원 이용을 제한하는 기능을 하는데, 이 기능은 도커 컨테이너에서 확장되어 이러한 컨테이너의 자원 이용을 제한하는 데 사용됩니다.

이러한 cgroups는 CPU, 메모리, 디스크 I/O, 네트워크 등 거의 모든 시스템 자원에 작용합니다. 따라서, cgroups는 컨테이너가 효율적인 공유 자원 관리를 쉽게 구현할 수 있도록 하는 기본 기능입니다.

이를 살펴보겠습니다:

<div class="content-ad"></div>

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_14.png)

위 그림은 컨테이너 내의 모든 시스템 자원이 프로세스 관련 cgroups에 의해 제어된다는 것을 명확히 보여줍니다. 시스템에서 실행되는 도커 컨테이너를 프로세스로 검사할 때, 각각의 리소스가 별도로 제어되는 것을 확인할 수 있습니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_15.png)

여기에서 이 컨테이너의 cgroup 기능을 이해하려고 노력했습니다. 이 기능은 메모리 사용량을 제어하고 제한합니다.

<div class="content-ad"></div>

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_16.png)

컨테이너 주변에 설정한 cgroups의 메모리 제한과 유사하게 CPU 사용량 제한도 설정되어 있습니다. 따라서 cgroups는 컨테이너 자원 활용, 제한 및 분리를 위한 핵심 기능이라고 할 수 있습니다.

# Docker 컨테이너와 네트워킹:

대부분의 Docker 컨테이너의 네트워크 구성 및 설정은 해당 컨테이너의 기능적 측면에 따라 달라집니다. 따라서 기능에 따라 6가지 사용 가능한 네트워크 유형, 즉 네트워크 드라이버 중 하나를 구성해야 합니다. 이에 따라 이러한 네트워크에 대해 간단히 이해하고 특이사항을 탐색해보겠습니다.

<div class="content-ad"></div>

도커에는 여섯 가지 유형의 네트워크 드라이버가 있어요:

- 호스트(Host): 컨테이너가 도커 호스트의 네트워크에 설정될 때 자동으로 생성하는 직접 병렬 연결이에요.

- 브릿지(Bridge): 대부분의 도커 컨테이너에 대한 기본 네트워크입니다.
    - 여기서 두 가지 유형이 있어요: 기본 브릿지 네트워크와 사용자 정의 브릿지 네트워크.
    - 여기에는 도커 호스트 포트를 명시적으로 컨테이너 포트에 연결하는 과정이 포함돼요.
    - 기본 브릿지 네트워크: 프로덕션 환경에서 권장되지는 않아요.
    - 사용자 정의: 가상 네트워크에 특정 인터페이스 중간 브리지를 사용하고, 모든 컨테이너가 이 공통 브리지를 통해 가상 이더넷으로 연결돼요. 또한 이는 컨테이너 간 통신을 제한해요.
    - 사용자 정의: 컨테이너 간 자동 DNS 해결이 가능해요.

<div class="content-ad"></div>

3. MAC-VLAN: 일반적으로 이전 시스템에서 사용되는 방법으로, 각 컨테이너가 가상으로 별도의 MAC 주소가 할당되어 외부 네트워크에 직접 연결된 것처럼 보이게 합니다.

- 그러나 이를 위해서는 물리 네트워크가 패킷 수신 모드로 작동해야 합니다. 이는 여러 MAC 주소가 단일 물리 인터페이스에서 발신되는 것을 의미합니다.
- 따라서 도커 호스트 중 하나의 물리 인터페이스를 지정해야 합니다.

4. IP-VLAN: 아마도 도커 네트워킹에서 가장 간단하고 번거로움이 없는 방법입니다.

- 간단히 말해, 이제 도커 호스트 상의 각 컨테이너에 직접적인 IP를 부여하고 레이어 2에 대한 복잡함 없이 관리합니다.
- 기능적으로 호스트를 로컬 라우터로 변환하여 서브넷 작업 및 L2 기능을 관리하고 각 컨테이너는 단순히 직접적인 IP를 제공받습니다.

<div class="content-ad"></div>

5. None: 컨테이너가 외부 네트워크나 호스트에 어떠한 방법으로도 연결할 수 없는 매우 격리된 환경에서 작동하는 네트워킹 드라이버입니다.

6. Overlay: 일반적으로 도커 스웜 네트워킹을 위해 사용됩니다.

# 전형적인 도커 컨테이너 침범 분석:

1. 취약한 도커 이미지와 이미지 백도어 기반 침범:

<div class="content-ad"></div>

- 모든 후속 도커 컨테이너 및 작업에 대한 중요성을 갖는 것은 도커 이미지와 그 적법성입니다. 따라서 이제 우리는 쉘쇼크와 같은 일반적인 취약점이 취약한 이미지를 사용함으로써 컨테이너를 취약하게 만들 수 있다는 것을 탐구해볼 것입니다.
- CVE-2014-6271은 쉘쇼크 취약 이미지로, 이를 사용하여 컨테이너를 생성하면 공격의 위험에 노출될 수 있습니다.

![도커 컨테이너 보안과 공격 방어 간단히 설명된 이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_17.png)

- 따라서 해당 컨테이너를 배포하고 서버로 사용할 때 우리가 쉘쇼크를 호출하는 유사한 페이로드를 사용하면, 우리는 성공적으로 /etc/passwd 파일에 액세스할 수 있습니다.
- 공격자는 이 컨테이너의 정확한 IP 주소에 액세스할 수 있으면 해당 주소로 역쉘을 실행하여 쉘쇼크를 악용할 수 있습니다.

![도커 컨테이너 보안과 공격 방어 간단히 설명된 이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_18.png)

<div class="content-ad"></div>

- 이 스크립트는 사용자 에이전트 헤더를 설정하여 악의적으로 실행되며, 이후 하위 쉘을 시작하고 이를 공격자의 IP에 연결하여 이 컨테이너 기반의 웹 앱을 취약하게 만듭니다.
- 이미지와 관련된 또 다른 흔한 악용 방법은 도커 레지스트리에서 가져온 도커 이미지를 감염시키는 도구를 사용하는 것인데, 이 감염은 보통 레지스트리에서 다운로드된 이미지에 백도어링하는 방식입니다.
- Dockerscan은 인기 있는 도구로 수정하고 트로이작화하며 원본 이미지를 변경하여 위와 같은 악용에 취약하도록 만듭니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_19.png)

- 마무리로, 기업 및 제조 환경에서 개인 도커 레지스트리를 갖추는 중요성과 이러한 이미지를 확인하는 메커니즘을 가지고 있는 중요성이 강조됩니다.

2. 컨테이너 볼륨 마운트 기반의 악용:

<div class="content-ad"></div>

- 도커 볼륨은 해당하는 도커 컨테이너에 영속적인 저장 공간을 제공하고, 명시적으로 마운트됩니다.
- 처음에는 이것이 완전히 정상적인 작업으로 보일지 몰라도, 때로는 이 볼륨 마운트가 더 높은 권한(때로는 루트)을 보유하고 있기 때문에 이를 통해 특권 상승을 통한 이스케이프 공격의 위협이 발생할 수 있습니다.
- 다른 디렉토리와 마찬가지로 도커 호스트에는 도커 클라이언트가 도커-데몬 및 다른 컨테이너에 효과적으로 연결하고 통신할 수 있도록 도와주는 도커.sock이라는 전용 UNIX 소켓이 있습니다.
- 이는 감사 및 특별 컨테이너 관리와 같은 용도에 유용해 보이지만, 적절하게 처리되지 않으면 복잡성으로 이어집니다. Docker.sock 마운트는 부적절한 도커 볼륨 마운트와 관리가 탈출을 일으킬 수 있고 특권 상승을 통해 공격자에 대한 취약점을 남길 수 있는 사례로 잘 분석할 수 있는 것입니다.
- 보통 호스트의 /var/run/docker.sock 디렉토리는 이 UNIX 소켓을 통해 연결을 가능하게 하고 설정할 수 있습니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_20.png)

- 이 디렉토리가 호스트에서 컨테이너로 공유 볼륨으로 마운트되면 이 컨테이너 안에서 접근할 수 있게 됩니다. 하지만 이를 악용하기 위해서는 커뮤니케이션을 위한 도커 클라이언트가 필요합니다. 따라서 공격자는 이 컨테이너에 도커를 추가하여 상황을 악화시킵니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_21.png)

<div class="content-ad"></div>

- 공격자는 여전히 액세스를 보유하고 있지만 이 마운트된 docker.sock 볼륨 마운트 내에서만 작업이 제한됩니다. 따라서, 이제 이 도커 클라이언트가 컨테이너 내부에 있고 컨테이너 내부에서 docker.sock 마운트 명령을 사용하여 호스트의 루트 디렉토리를 이용해 다른 컨테이너를 생성하는 공격이 발생합니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_22.png)

- 이것이 권한 상승이 발생하는 곳입니다. 이제 침해된 컨테이너가 다른 마운트된 루트 볼륨으로 구성된 다른 컨테이너를 완전히 제어하게 됩니다.
- 주의해야 할 또 다른 특이한 사항은 우리가 컨테이너를 완전히 삭제하더라도 볼륨이나 권한이 중요한 루트에 대한 액세스를 중지하지 않는다는 것입니다. 이는 우리가 볼륨 위치를 쉽게 검사하고 찾을 수 있도록 도와주므로, 사용자들은 볼륨을 다룰 때 주의해야 합니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_23.png)

<div class="content-ad"></div>

3. 도커 원격 API 기반의 취약점:

- 도커 원격 API를 사용하면 도커의 원격 관리 액세스를 제외시킴으로써 호스트의 도커 데몬에 REST API를 통해 연결할 수 있습니다.
- 도커 엔진을 명시적으로 설정해야만 도커 데몬을 REST 원격 API를 통해 노출할 수 있습니다. 따라서 도커 데몬을 모든 인터페이스(tcp://0.0.0.0:2375)에서 노출시킵니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_24.png)

- 공격자가 이러한 노출된 엔드포인트에 대해 알게 되면 도커 호스트로 작동하는 즉시 특권 상승 및 루트 액세스를 시도합니다. reverse-shell과 같은 공격 메커니즘을 통해 해당 호스트로의 액세스를 얻기 위해 아래에 제공된 적재 기반 명령을 공격자가 원격으로 사용합니다.

<div class="content-ad"></div>


이미지 태그를 Markdown 형식으로 변경해보겠습니다.

- Docker -H 옵션은 대상 호스트 데몬을 지정하며, 호스트의 루트 디렉토리를 결과 컨테이너에 마운트하도록 지시한 후, 해당 컨테이너에서 셸을 실행하여 공격자의 원격 IP 노드로 셸을 실행합니다.
- 이후 이 침투된 컨테이너를 통해 호스트의 루트 파일에 액세스하고, /etc/passwd 및 /etc/shadow에 자격 증명을 추가하여 이 루트 자격 증명을 통해 대상 기계에 SSH를 시도합니다.

<div class="content-ad"></div>

4. 기능 기반 악용, 특권 플래그, 그리고 도커 시크릿:

- 리눅스 커널과 도커 컨테이너에는 컨테이너 기능이라는 구조가 있습니다. 이는 컨테이너가 독립적으로 실행할 수 있는 작업에 대한 능력을 규제합니다.
- 이러한 기능은 기본적으로 도커 컨테이너의 경우 제한된 숫자로 설정되어 있지만, 도커 --privileged 플래그를 사용하여 컨테이너를 빌드하는 경우 이러한 컨테이너는 모든 가능한 기능을 부여받습니다.
- 이로 인해 컨테이너가 호스트와 유사한 기능에 대한 액세스 거의 어디든지 얻게 됩니다.
- 이러한 컨테이너 기능들 간의 차이를 분석하고 비교하세요:

기본 기능:

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_28.png)

<div class="content-ad"></div>

프리빌리지드 캡들:

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_29.png)

- 하지만 이러한 몇 가지 확장된 권한은 축복이자 재앙이 될 수 있습니다. 이러한 특정 확장된 기능인 CAP_SYS_MODULE로 인한 간단한 악용이 발생합니다. 이 권한은 특권이 부여된 플래그가 지정된 컨테이너에게 주어집니다.
- 결과적으로, 이로써 해당 컨테이너는 호스트의 커널 공간에 직접적으로 쓰기 기능을 갖추게 되어 파괴적인 결과를 초래할 수 있습니다.
- 공격자들은 이로 인해 특권이 주어진 컨테이너에 액세스하게 되어 호스트의 커널 공간에 이 컨테이너를 통해 인-커널 모듈을 실행하게 합니다.
- 모든 시스템은 운영 및 컴퓨팅 공간을 분리하고, 커널 공간은 시스템의 백그라운드 및 기본 모듈을 실행하는 데 사용되며, 이후 어플리케이션은 유저 공간에 존재하고 활용합니다.
- 리눅스 커널은 소스 코드를 수정하지 않고도 런타임 기반의 다중 기능(동적 모듈) 추가를 허용하도록 구조화되어 있습니다. 공격자들이 여기에서 이용하는 추가 모듈이 시스템을 방해하는 데 사용됩니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_30.png)

<div class="content-ad"></div>

- 위는 공격자가 호스트의 커널 공간으로 컨테이너를 통해 로드할 수 있는 타입의 커널 모듈입니다.
- 이는 호스트의 커널 로그에 영향을 미치고 임의의 코멘트와 로그를 감염시키는 일반적인 커널 모듈로, 비슷하게 커널 모듈은 해당 호스트에 대해 역쉘 공격을 발동할 수 있는 확장 기능을 가질 수 있습니다.
- 역쉘 모듈

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_31.png)

도커 시크릿 관리:

- 이러한 도커 시크릿은 일반적으로 컨테이너 내에서 사용되는 중요한 데이터 내용인데, 응용프로그램 및 서비스 자격 증명부터 운영 매개 변수까지에 사용됩니다.
- 도커 컨테이너에 단순히 존재하므로 적절한 관리와 처리가 여기서 중요한 문제가 됩니다.
- 데이터베이스 및 사용자 자격 증명과 같은 정보들이 환경 변수의 형태로 도커 파일에 저장되어 컨테이너에 저장됩니다.

<div class="content-ad"></div>

![2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_32.png](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_32.png)

![2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_33.png](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_33.png)

![2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_34.png](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_34.png)

- 이제 공격자가 컨테이너 내부 또는 호스트의 도커 엔진에 접근하면 이러한 비밀이 쉽게 유출될 수 있습니다. 따라서 도커 비밀을 안전하고 격리된 저장 및 관리가 필수적입니다.

<div class="content-ad"></div>

# 방어 및 취약성 평가:

- Trivy는 자주 사용되며 매우 유용한 오픈 소스 타사 도구로, 도커 이미지에 대한 자동 취약성 평가에 널리 사용됩니다. 이 도구 자체가 사전에 빌드된 이미지를 통해 도커 환경 내에서 컨테이너로 실행됩니다.
- 적절한 모드에서 실행 이미지와 함께 실행하려면 먼저 이미지를 가져와야 합니다.

![Trivy](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_35.png)

Trivy는 취약성 ID, 심각성, 패치된 버전 설치 상태 등의 형태로 결과를 정렬하여 반환합니다. 모든 취약성을 패치한 후에 다시 실행해야 합니다.

<div class="content-ad"></div>

- 도커 벤치 보안은 컨테이너 런타임 기반으로 취약성 평가를 자동화하는 데 사용되는 인기 있는 도구 중 하나입니다.
- 이 도구는 기본 컨테이너의 보안 취약성을 분석하고, 보안 측면에서의 결핍에 기반한 분석적 경고와 경보를 생성합니다. 이 도구는 컨테이너 보안의 다양한 측면에 대한 구간별 분석을 제공합니다. 최종 결과로, 수행한 총 확인 항목에 대한 특정 점수를 제공합니다.

<div class="content-ad"></div>

![image](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_39.png)

여러 방어 방법:

- Seccomp 사용하기:
    - 리눅스 커널의 안전한 컴퓨팅 기능으로 널리 알려져 있으며, 주요 역할은 내부적으로 이 시스템에 방화벽 역할을 하여 생성된 시스템 호출을 범주화하여 제한하는 것이다. 따라서 프로세스의 권한을 격리시켜 시스템 호출을 제어함으로써 프로세스의 권한을 샌드박스화할 수 있는 기능을 제공한다.
    - 방화벽 정책과 유사하게 시스템 호출을 제한하기 위한 규칙으로 구성된 seccomp 프로필 정책을 실행하여 사용해야 한다. 이러한 제한사항을 수행하고 지정하기 위한 기본 구문이 있다.
    - 기본적으로 Docker는 300개 이상의 시스템 호출 중 44개를 허용하는 seccomp 정책을 사용한다. 아래는 "chmod" 시스템 호출을 제한하는 방법이다.

<div class="content-ad"></div>

2. 또 다른 유사한 방어 방법은 "Apparmor"을 사용하는 것인데, 이는 리눅스 보안 모듈로 매우 포괄적이며 다양한 컨테이너 및 응용 프로그램에 연관된 사용자 지정 프로필을 통해 OS 자원에 대한 액세스를 관리하는 더 큰 목적을 제공합니다.

![이미지](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_40.png)

Apparmor는 의무적 액세스 제어에서 임의적 액세스 제어, 네트워크에서 파일 경로 등 다양한 영역까지 매우 포괄적으로 사용됩니다.

3. 능력 사용하기:

<div class="content-ad"></div>

컨테이너의 기능과 관리 방법이 특권 상승 공격을 예방하는 데 중요합니다.
-- 특권 플래그는 컨테이너에 완전한 기능을 부여하는 능력을 제공하기 때문에 이러한 기능을 보안 문제에 맞춰 세분화하여 제어할 수 있으며, 그러므로 이러한 제한은 반드시 시행되어야 합니다.

![image](/assets/img/2024-07-09-SimplifiedDockerContainerSecurityCommonExploitsandDefenses_41.png)

위와 같이 --cap-drop은 이후 컨테이너에서 CHOWN 명령 기능을 제한합니다.

<div class="content-ad"></div>

- 이 플래그는 공개 레지스트리에서 직접 가져온 악의적으로 수정된 도커 이미지에 대한 어느 정도의 방어 기능을 제공합니다. 따라서 레지스트리에서 서명되지 않은 악의적 이미지의 사용을 방지합니다. 이 문제를 완전히 해결해 주진 않지만 보호층을 제공합니다.

작성자: Nitish Deshpande