---
title: "리액트 컴파일러 무엇인가요 그리고 프론트엔드 개발에 어떻게 영향을 미칠까요"
description: ""
coverImage: "/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png"
date: 2024-05-12 19:30
ogImage: 
  url: /assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png
tag: Tech
originalTitle: "React Compiler: What Is It and How Will It Change Frontend Development?"
link: "https://medium.com/@semaphoreci/react-compiler-what-is-it-and-how-will-it-change-frontend-development-f7ce837d1852"
---


React 18가 이미 2년 이상 지난 후에, 이제는 React 19를 환영할 때가 왔습니다. 우리가 모두 사랑하는 주요 혁신은 React 컴파일러입니다! 이는 수동 메모이제이션 최적화가 필요 없어져서 프론트엔드 개발을 영원히 간단히 해 줄 것을 약속합니다.

이 안내서에서는 React 컴파일러가 무엇인지, 어떻게 작동하는지, 어떤 이점을 제공하는지, 그리고 응용 프로그램을 준비하는 방법에 대해 이해하게 될 것입니다.

# React 19가 가져올 혜택

React 19는 2024년 5월 15일부터 16일에 React Conf 2024에서 발표될 예정이며, 이 프레임워크의 오랫동안 기다려온 다음 버전입니다. React 18은 2022년에 출시되었고, 그 이후로 웹 기술이 크게 발전해 왔습니다. 이제는 업데이트할 때가 왔습니다.



![React Compiler](/assets/img/2024-05-12-ReactCompilerWhatIsItandHowWillItChangeFrontendDevelopment_0.png)

버전 19는 앞으로 나아갈 한 걸음일 뿐만 아니라, React 애플리케이션을 만드는 방법을 영원히 바꾸어 놓을 것입니다. React 19가 소개할 가장 흥미로운 기능 중 일부는 다음과 같습니다:

- 서버 컴포넌트: 더 빠른 페이지 로딩과 더 나은 SEO를 위한 컴포넌트 서버사이드 렌더링. 서버에서 컴포넌트를 처리하여 페이지를 사용자에게 제공하기 전에, React 19는 웹사이트의 로딩 시간을 빠르게 하고, 검색 엔진 노출도를 향상시키며, 더 부드러운 데이터 관리를 가능하게 합니다. 이미 Next.js가 이 기능을 사용하고 있습니다.
- 액션: 웹 페이지 내 데이터 및 상호작용 관리를 간소화합니다. 액션은 양식을 통해 페이지 정보를 업데이트하는 작업을 간단하게 만들어 복잡성을 줄이고 사용자 경험을 단순화합니다.
- 최적화된 자산 로딩: 더 부드러운 페이지 전환을 위해 사이트 자산을 백그라운드에서 로드합니다. React 19는 사용자가 현재 페이지를 둘러 보는 동안 이미지 및 다른 파일을 백그라운드에서 로드하여 페이지 전환 중 대기 시간을 줄입니다.
- 문서 메타데이터: 새로운 `DocumentHead` 컴포넌트 덕분에 간단한 SEO 관리. 페이지에 제목 및 메타 태그를 추가하는 것이 더 직관적으로 되어 검색 엔진 최적화를 향상시키는 반복적인 코딩을 필요로 하지 않습니다.
- 웹 컴포넌트: 더 유연하고 호환성이 높은 프론트엔드 개발을 위한 웹 컴포넌트 표준과의 향상된 호환성.
- 향상된 훅: 기존 및 새로운 훅을 통해 컴포넌트의 라이프사이클과 상태를 더 세밀하게 제어합니다. 최종 목표는 코딩 프로세스를 단순화하여 React 개발을 더 효율적이고 즐겁게 만드는 것입니다.
- React 컴파일러: React 코드를 표준화된 최적화된 JavaScript 코드로 자동 변환합니다. 상태 변경 시 UI의 올바른 부분만 자동으로 렌더링하도록 컴파일된 React 코드를 허용하여 useMemo, useCallback 및 memo의 필요성을 줄입니다. 이는 단순화된 코드 기반으로 빠른 React 애플리케이션을 의미합니다.

이 모든 기능들은 훌륭하지만 가장 눈에 띄는 것은 React 컴파일러입니다. 이 업그레이드는 React 개발을 영원히 바꿀 것을 약속합니다. 이제 왜 그렇게 생각하게 되었는지와 어떠한 혜택을 제공할지 이해해보도록 하겠습니다!



# React 컴파일러: 알아야 할 모든 것

React 19 컴파일러 도구를 자세히 살펴보며, 이 도구가 무엇인지와 어떻게 작동하는지 알아봅니다.

# React의 핵심 메인 모델

React 컴파일러 뒤에 숨겨진 이유를 이해하려면 먼저 몇 가지 주요한 React 개념을 탐구해야 합니다.



React의 핵심은 선언적이고 컴포넌트 기반의 메타 모델에 있습니다. 프론트엔드 개발에서 선언적 프로그래밍은 UI의 원하는 최종 상태를 설명하되 DOM 조작을 통해 각 단계를 명시하지 않고 도달하는 방법을 설명하는 것을 의미합니다. 한편, 컴포넌트 기반 접근 방식은 UI 요소를 재사용 가능하고 간결하며 독립적인 빌딩 블록으로 분해하여 모듈화 및 유지 보수의 용이성을 촉진합니다.

특정 DOM 요소를 식별하여 업데이트해야 할 때, React는 가상 DOM이라고 불리는 사용자 인터페이스의 인메모리 표현을 활용합니다. 애플리케이션 상태 변경이 발생할 경우, React는 가상 DOM을 실제 DOM과 비교하여 필요한 최소한의 변경 사항을 식별하고 정확하게 실제 DOM을 업데이트합니다.

간단히 말하면, React는 애플리케이션의 상태가 변경될 때마다 다시 렌더링합니다. 그러나 때로는 React가 지나치게 반응적일 수 있어 애플리케이션을 심각하게 느리게 만드는 불필요한 다시 렌더링이 발생할 수 있습니다.

# 다시 렌더링 지옥: 컴파일러 필요성



리액트는 애플리케이션 상태 변화에 민첩하게 대응하는 데 장단점이 있어요. 한편으로는 선언적인 방식을 통해 프론트엔드 개발을 간단하게 만들어 줍니다. 다른 한편으로는 상태 변경에 따른 UI 내 컴포넌트의 지나친 다시 렌더링으로 이어질 수 있어요.

자바스크립트 데이터 구조인 객체와 배열을 다룰 때 특히 다시 렌더링 문제가 일반적으로 발생할 수 있어요. 문제는 두 객체나 배열이 동등한지(동일한 키와 값들을 가지고 있는지) 비교할 수 있는 계산적으로 효율적인 방법이 자바스크립트에는 없다는 것이에요.

다음 시나리오를 고려해 보세요. 각 렌더링마다 새 객체나 배열을 생성하는 리액트 컴포넌트가 있다고 가정해 봅니다. 아래 예시와 같이요:

```js
import React from "react";
```



```js
const AlphabetList = () => {
  // 알파벳 배열 정의
  const alphabet = Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));
  return (
    <div>
      <h2>알파벳 목록</h2>
      <ul>
        {/* 알파벳을 목록 항목으로 렌더링 */}
        {alphabet.map((letter, index) => (
          <li key={index}>{letter}</li>
        ))}
      </ul>
    </div>
  );
};
export default AlphabetList;
```

로컬 배열의 내용이 각 렌더링마다 동일할지라도, React는 그 사실을 효율적으로 알 수 없습니다. 결과적으로, 배열 값에 의존하는 구성 요소의 중첩 DOM 요소에서 재렌더링이 발생할 수 있으며 UI가 동일하게 유지되어야 한다는 사실을 인식하지 못합니다. 이러한 재렌더링 메커니즘은 빠르게 무제한적으로 힘을 쏟아내어 애플리케이션 성능과 사용자 경험에 상당한 영향을 미칠 수 있습니다.

재렌더링 동작을 최적화하고 이러한 문제를 피하기 위해 React 개발자들은 구성 요소에 수동으로 메모이제이션을 도입해야 합니다. React에서 메모이제이션은 비싼 계산 또는 구성 요소 출력의 결과를 캐싱하는 것을 포함하며 입력 매개변수에 기반합니다. 이러한 결과를 저장하고 재사용함으로써 메모이제이션은 구성 요소의 불필요한 다시 읽기를 방지하고 React 애플리케이션의 전체 효율성과 성능을 향상시킵니다.

React 18은 여러 가지 메모이제이션 도구를 제공합니다:




- React.memo(): 프롭이 변경되지 않은 경우 컴포넌트의 다시 렌더링을 피하기 위한 하이어오더 함수입니다.
- useMemo(): 재렌더링 사이에 계산 결과를 캐시하는 React 훅으로, 중복된 계산을 줄입니다.
- useCallback(): React에서 함수 정의를 캐시하여 불필요한 함수 재생성을 피하는 훅입니다. React의 useCallback() 훅에 대해 자세히 알아보세요.

useMemo() 훅 덕분에 `AlphabetList` 컴포넌트를 최적화하여 불필요한 재렌더링을 피할 수 있습니다. 아래와 같이 구현할 수 있습니다:

```js
import React, { useMemo } from "react";
```

```js
const AlphabetList = () => {
  // useMemo()을 사용하여 알파벳 배열을 정의합니다.
  const alphabet = useMemo(() => {
    return Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i));
    // 의존성이 없으므로 첫 렌더링 시에만 계산됩니다.
  }, []);
  return (
    <div>
      <h2>알파벳 리스트</h2>
      <ul>
        {/* 알파벳을 리스트 아이템으로 렌더링합니다. */}
        {alphabet.map((letter, index) => (
          <li key={index}>{letter}</li>
        ))}
      </ul>
    </div>
  );
};
export default AlphabetList;
```



리액트에서 제공하는 메모이제이션 도구들은 정말 강력해요. 동시에 이를 도입하는 것은 리액트의 핵심적인 메타모델인 선언적 철학과는 명확히 달라요. 개발자들에게 부담을 주는데, UI의 최종 상태뿐만 아니라 렌더링 최적화를 명시적으로 관리해야 해요. 수동 메모이제이션은 코드 복잡성과 유지보수의 어려움을 도입하게 해요.

해결책은 무엇일까요? 리액트 코드를 최적화된 JavaScript 코드로 변환하는 고급 컴파일러입니다. 이를 통해 상태 값이 크게 변경된 경우에만 컴포넌트가 자동으로 다시 렌더링되도록 할 수 있어요.

# 리액트 컴파일러란 무엇인가요?

리액트 컴파일러, 또는 리액트 포겟으로도 알려진 이것은 리액트를 위한 최적화 컴파일러에요. 지금은 인스타그램의 웹 포털에서 사용되고 있으며, 첫 번째 오픈 소스 릴리스 전에 다른 메타 어플리케이션에 배포될 예정이에요.



컴파일러의 초기 목표는 React의 핵심 프로그래밍 모델을 강제로 적용하여 memo, useMemo 및 useCallback 호출의 동등물을 자동으로 생성하여 다시 렌더링 비용을 최소화하는 것이었습니다. 이 프로젝트는 "자동 메모이징 컴파일러"에서 "자동 반응성 컴파일러"로 크게 발전했습니다.

지금의 React Forget의 진짜 목표는 React 애플리케이션이 기본적으로 적절한 반응성을 갖도록 보장하는 것입니다. 다시 말해, 앱은 상태 값이 의미 있는 변화가 있을 때에만 다시 렌더링되어야 합니다. 현재 React는 객체 식별이 변경될 때 구성요소를 다시 렌더링합니다. 그러나 React Forget를 사용하면 객체의 의미적 값이 변경될 때에만 다시 렌더링되지만 심층 비교의 런타임 비용을 지불하지 않습니다.

구현 관점에서 React Compiler는 자동 메모이제이션을 적용합니다. 그러나 이를 제작한 팀은 반응성 프래밍을 이해하는 더 완전한 방법으로 간주합니다. React 컴파일러의 내부 작업 및 논리에 대해 자세히 알고 싶다면 React Labs 섹션의 해당 내용을 읽어보세요.

아래 비디오에서 React Forget의 작동을 확인하세요: [여기를 클릭하세요](https://www.youtube.com/watch?v=qOQClO3g8-Y&)



자바스크립트는 동적 성격과 느슨한 규칙 때문에 최적화하기 어렵다는 것으로 유명합니다. 그러나 React Compiler는 JavaScript 규칙과 "React의 규칙"을 모델링하여 코드를 안전하게 컴파일할 수 있습니다. 이러한 규칙은 개발자들이 할 수 있는 일을 제한하여 컴파일러가 최적화 작업을 수행할 안전한 공간을 마련합니다.

# React의 규칙

React는 고품질 웹 애플리케이션을 지원하기 위해 고안된 규칙 세트와 함께 제공됩니다. 개발자들은 이러한 규칙을 따라야 하며, 이는 React Compiler가 기반으로 하는 것과도 일맥상통합니다.

React의 가장 중요한 규칙 중 일부는 다음과 같습니다:



- 컴포넌트는 idempotent해야 합니다: React 컴포넌트는 항상 동일한 출력물을 생성해야 합니다. 입력값으로는 props, state 및 context가 포함됩니다.

- 사이드 이펙트는 렌더링 외부에서 실행되어야 합니다: 데이터 가져오기, 구독 또는 수동으로 DOM을 변경하는 사이드 이펙트는 컴포넌트의 렌더링 프로세스 중에 수행해서는 안 됩니다. 대신에 useEffect와 같은 라이프사이클 훅에서 실행되어야 합니다.

- Props와 state는 불변해야 합니다: React 컴포넌트의 props와 state는 불변으로 취급되어야 합니다. 직접 수정해서는 안되며, props 또는 state를 직접 변경하는 것은 버그와 예측할 수 없는 작동을 유발할 수 있습니다.

- 훅에 대한 반환 값 및 인수는 불변해야 합니다: 값이 React 훅에 전달된 후에는 수정해서는 안 됩니다. 훅은 인수와 반환 값을 변경하지 않음으로써 컴포넌트 동작의 일관성과 예측 가능성을 유지합니다.

- JSX에 전달된 값은 불변해야 합니다: 렌더링된 후 JSX에서 사용된 값은 변형해서는 안 됩니다. 필요한 변형은 렌더링된 JSX 이전에 수행되어야 하며, 이를 통해 렌더링된 출력물이 일관되게 유지됩니다.

- 컴포넌트 함수를 직접 호출하지 말아야 합니다: React 컴포넌트는 JSX 내부에서만 사용되어야 하며, 일반 함수처럼 직접 호출해서는 안 됩니다.

- 훅을 일반 값처럼 전달하지 마세요: useState나 useEffect와 같은 React 훅은 함수형 컴포넌트 내부에서만 호출되어야 합니다. 이를 일반 값으로 사용하는 것은 예상치 못한 동작을 유발하고 훅 규칙을 위반할 수 있습니다.

- 훅은 항상 최상위 수준에서 호출해야 합니다: React 훅은 항상 함수형 컴포넌트의 최상위 수준에서 호출해야 하며, 어떠한 조건문이나 반복문보다 먼저 호출되어야 합니다. 이렇게 함으로써 훅이 모든 렌더링에서 동일한 순서로 호출되고 의도한 동작을 유지합니다.

- React 함수에서만 훅을 호출해야 합니다: 훅은 React 함수 컴포넌트나 사용자 정의 훅 내부에서만 호출해야 합니다. 일반 JavaScript 함수에서 훅을 호출하는 것은 오류를 유발할 수 있으며 훅 규칙을 위반합니다.

Strict Mode를 활성화하고 React의 ESLint 플러그인을 구성하여 React 애플리케이션이 이러한 규칙을 준수하도록하세요.

# 이점과 희망

React Compiler에 의해 제공되는 주요 이점은:



- 더 이상 메모이제이션에 대한 골치 아픔이 없어졌어요: 개발자들은 이제 코드에서 메모이제이션 전략을 수동으로 구현하고 관리할 필요가 없습니다. 이로 인해 복잡성과 오류 가능성이 줄어들며 개발 프로세스가 간소화됩니다.
- 개발자 경험이 더 나아졌어요: 개발자들은 기능 구축에 더 집중하고 성능 최적화에 덜 신경 쓸 수 있어서 생산성과 만족도가 높아졌어요. 이제 React 선언적 접근 방식을 완전히 받아들일 수 있을 거에요.
- 빠른 React 애플리케이션: 필요할 때만 컴포넌트를 렌더링하여 불필요한 계산과 오버헤드를 최소화해요. 이로 인해 빠르고 반응성이 높은 사용자 인터페이스를 구현할 수 있어 전체 성능과 사용자 경험이 개선됩니다.

이 모든 것들은 흥미로운 변화이지만, 이 새로운 도구가 코드 개발에 미치는 영향을 아직 보지 못했어요. 컴파일러가 제대로 작동하기 위해서는 코드가 React 규칙을 준수해야 해요. 공식팀이 ESLint와 같은 도구를 도입하여 React 컴파일러를 위해 애플리케이션을 준비하는 것을 권장하는 이유가 여기 있어요.

# React 컴파일러: 프론트엔드 혁명?

React 컴파일러가 프론트엔드 개발 영역에서 진정한 혁명을 일으킬 만큼 충분할지는 곧 알 수 있을까요. 확실한 것은, 이 컴파일러가 미래의 React 애플리케이션 개발을 크게 변화시킬 자격이 있다는 것입니다. 자동 메모이제이션을 도입함으로써, 이 컴파일러는 React 애플리케이션의 속도를 자동으로 향상시키고 개발자 경험을 향상시킬 수 있어요. 이 야심찬 프로젝트가 가져다 주는 혜택 중 일부일 뿐이에요.



React Conf 2024가 곧 다가오고 있으니, 이 야심찬 프로젝트가 프론트엔드 세계에 미칠 혁신을 기대해 봅니다!

원문은 2024년 5월 9일 https://semaphoreci.com에서 게시되었습니다.