---
title: "러스트를 사용한 것이 괜찮았나요"
description: ""
coverImage: "/assets/img/2024-05-12-WasRustWorthIt_0.png"
date: 2024-05-12 23:55
ogImage: 
  url: /assets/img/2024-05-12-WasRustWorthIt_0.png
tag: Tech
originalTitle: "Was Rust Worth It?"
link: "https://medium.com/@jsoverson/was-rust-worth-it-f43d171fb1b3"
---


![2024-05-12-WasRustWorthIt_0](/assets/img/2024-05-12-WasRustWorthIt_0.png)

몇 년 전에 나는 모든 것을 내려놓고 WebAssembly에 100% 집중하기로 결심했습니다. 그 당시에 Rust는 WebAssembly로 컴파일하는 데 가장 좋은 지원을 제공했으며, 가장 기능이 풍부한 WebAssembly 런타임은 Rust 기반입니다. Rust가 메뉴에서 최상의 선택이었습니다. 나는 그 호기심이 어디에서 나왔는지 알기 위해 들어갔습니다.

그 이후로 나는(다른 멋진 사람들과 함께) WebAssembly를 핵심 모듈 시스템으로 사용하는 응용 프레임워크 및 런타임인 Wick를 만들었습니다.

![2024-05-12-WasRustWorthIt_1](/assets/img/2024-05-12-WasRustWorthIt_1.png)



수년의 경력, 다양한 제품 배포, ebook, 그리고 crates.io에 배포된 ~100개의 패키지가 있으니 Rust에 대한 생각을 공유할 시간이 된 것 같아요.

# 좋은 점

## 더 많은 것을 적은 노력으로 유지할 수 있어요

저는 테스트 주도 개발을 강력히 지지해요. 자바, 자바스크립트 같은 언어에서 테스트에 익숙해졌어요. Rust에서도 다른 언어와 마찬가지로 테스트를 작성했지만, 실패할 수 없는 테스트를 작성하게 된 걸 발견했어요. Rust 코드가 컴파일될 수 있는 지점에 도달하면 많은 오류를 고려하여 많은 일반적인 테스트 사례가 관련이 없어집니다. ''unsafe'' 블록이나 .unwrap()과 같은 패닉이 발생할 수 있는 메서드를 피한다면, 기본으로 많은 문제를 우회하는 기반이 생기게 됩니다.



러스트의 빌림 검사자의 강인함, 러스트의 타입 시스템의 풍부함, 함수형 패턴 및 라이브러리, 그리고 "null" 값이 없는 것은 테스트하는 데 들이는 노력이 적은 상태로 더 많은 것을 유지하도록 이끕니다. Wick 프로젝트의 70,000줄 이상의 코드를 다른 언어에서 필요한 것보다 훨씬 적은 테스트로 유지했습니다.

테스트를 작성해야 할 때, 그냥 추가해도 괜찮은 거예요. 러스트의 통합 테스트 하네스를 사용하면 코드 옆에 거의 생각 없이 테스트를 추가할 수 있습니다.

## 이제 다른 언어에서 더 잘 코딩합니다

러스트에서 코딩하는 것은 감정적으로 학대를 당하는 것과 같습니다. 러스트는 하루 종일 당신에게 소리치고, 종종 다른 생활에서는 완전히 정상적으로 여겼을 일에 대해 소리를 질러요. 결국, 그 소리를 듣는 데 익숙해져요. 그것들이 일상이 되어요. 당신은 컴파일러의 화를 부르지 않도록 갈고리를 걷는 법을 배워요. 그리고 실제 생활에서처럼, 그 행동 변화는 영원히 당신과 함께 남아 있습니다.



정서적 학대는 일반적으로 변화를 격려하는 건 건강한 방법으로 여기지 않지만, 그럼에도 불구하고 변화를 일으킵니다.

다른 언어로 코드를 작성할 때 순서가 맞지 않을 때나 반환 값이 확인되지 않을 때 불편함을 느낍니다. 런타임 오류가 발생하면 이성적으로 화가 나게 됩니다.

![이미지](/assets/img/2024-05-12-WasRustWorthIt_2.png)

## Clippy 정말 좋아요!



크리피는 러스트의 린터입니다, 하지만 그것을 그냥 린터라고 부르는 것은 조금 과분한 것 같아요. 컴파일러가 당신을 울게 할 수 있는 언어에서, 크리피는 린터보다는 오히려 친절한 친구 같아요.

러스트 표준 라이브러리는 거대해요. 많은 기능이 다양한 작은 유형, 트레이트, 매크로, 함수에 걸쳐 퍼져 있기 때문에 이미 존재할 것으로 알고 있는 함수를 찾기가 어려워요. 많은 크리피 규칙들(예: `manual_is_ascii_check`)은 표준 라이브러리의 메서드나 유형이 더 나은 대체물이 될 수 있는 일반적인 패턴을 찾아냅니다.

크리피는 성능, 가독성 및 불필요한 간접 참조를 다루는 수백 개의 규칙을 가지고 있습니다. 가능한 경우 대체 코드를 자주 제시해 줄 거예요.

또한 (곧) 프로젝트용 전역 린트를 구성할 수 있게 될 것 같아요. 지금까지는 프로젝트의 일관성을 유지하기 위해 해킹 해야만 했어요. Wick에서는 몇 십 개의 크레이트에 대한 인라인 린트 구성을 자동으로 업데이트하는 스크립트를 사용해요. 러스트 커뮤니티가 이를 위한 해결책을 찾아내기까지 몇 년이 걸렸는데, 그 결과가 이런 것이 되었군요...



# 나쁜 점

## 살아가야 할 공백이 있습니다

제가 위의 Clippy 문제로 다시 돌아올 때마다 제 정신을 의심했어요. 분명히 제가 잘못했을 거예요. 빠뜨린 설정이 있을 테니까요. 그것을 믿을 수 없었어요. 지금도 그런 생각이 들어요. 린트를 전역으로 구성할 수 있는 방법이 있을 텐데요. 이 글을 쓸 때 현실감 있는지 확인하려고 네 번이나 확인했어요. 이제는 그 문제들이 해결되었지만 그동안 몇 년 동안 계속되었었어요.

Clippy는 멋지지만 이러한 사용 사례가 러스트 세계 여러 곳에서 자주 발생합니다. 내 사용 사례가 다루지 않는 라이브러리나 도구를 자주 만나게 돼요. 새로운 언어나 프로젝트에서 이것이 일반적이죠. 소프트웨어는 시간(사용)이 걸려 성숙해져야 해요. 하지만 러스트는 그렇게 새로운 게 아니에요. 러스트에는 다른 느낌이 있는 거거든요.



오픈 소스에서 에지 케이스는 초기 채택자와 새로운 사용자들에 의해 자주 다뤄집니다. 그들이 바로 에지 케이스를 가지고 있는 사람들이죠. 그들의 PR은 프로젝트를 개선하여 다음 사용자들에게 더 좋은 환경을 제공합니다. Rust는 거의 10년 동안 "가장 사랑받는 언어"로 선정되었습니다. 새로운 사용자를 유치하는 데는 어려움이 없지만, 이로 인해 혁신적으로 개선된 라이브러리나 도구가 나오지는 않습니다. 대신 특정 사용 사례를 다루는 일회성 포크가 나오는 것이 일반적입니다. 저 또한 그 중 하나인데요, 그것은 PR을 제출하려는 노력 부족 때문은 아닙니다.

왜 그럴까요. 안정적인 API를 유지하는 압력과 Rust의 세밀한 유형 시스템으로 인해 라이브러리 소유자들이 반복적인 작업을 하는 것이 어려울 수 있습니다. 만약 작은 변경 사항이 큰 버전 상향을 야기하는 경우 소수의 변경 사항을 수용하기가 어려울 수 있습니다.

아니면 모든 사람을 위해 모든 일을 처리하는 Rust 코드를 작성하는 것이 극도로 어렵기 때문에 사람들이 그것을 다루고 싶어하지 않을 수도 있습니다.

## Cargo, crates.io 및 프로젝트 구조화 방법



다른 인기있는 프로젝트를 보고 Wick 저장소 구조를 모델로 만들었어요. 합리적으로 보였고 제대로 작동했어요, 근데 언젠가부터는 문제가 발생했어요.

Cargo를 이용하면 모듈 크기의 상자를 쉽게 만들고 테스트할 수 있어요. 하지만 crates.io로 배포하는 건 전혀 다른 이야기네요.

crates.io로 패키지를 게시하려면 각각의 참조된 크레이트가 개별로 게시되어 있어야 해요. 그게 납득이 가는 부분이죠. 저차원의 파일시스템에만 존재하는 패키지에 의존하고 싶지 않잖아요.

하지만 많은 개발자들이 큰 프로젝트를 자연스럽게 작은 모듈로 분할하는데, 자기 자신 안에만 존재하는 하위 크레이트를 가진 상위 크레이트를 게시할 수 없어요. 심지어 로컬 개발 의존성을 가진 크레이트도 게시할 수 없답니다. 이 문제를 피하려면 무작위 유틸리티 크레이트를 게시할지, 프로젝트를 다시 구조화할지 선택해야 해요. 이 제약은 임의적이고 불필요하다는 느낌이 들어요. 이렇게 구조화된 프로젝트를 만들 수는 있지만, 게시할 수는 없다는 게 함정이죠.



카고는 역시 우수한 작업 공간 지원이 있어요! 카고의 작업 공간은 대부분의 언어보다 큰 프로젝트를 더 잘 관리할 수 있는 경험을 제공해줘요. 하지만 배포 문제를 해결해 주지는 않아요. 사실, 작업 공간을 설정하는 방법은 수십 가지중 어느 것도 배포를 쉽게 해결해 주지 않아요.

이 문제는 실용적인 유틸리티 크레이트 수가 많아서 발생합니다. 각각은 일부 구성과 함께 작동하며, 아직까지 작업 공간을 설정하는 "진정한 방법"은 제가 아직 찾지 못했어요. Wick를 게시할 때, 수동적이고 반복적인 작업을 부분적으로만 작동하는 도구와 결합하는 노력이 자주 1시간 이상 걸려요.

## Async

Rust는 시작 이후에 비동기성을 언어에 추가했어요. 이것은 나중에 생각한 것처럼 느껴지고, 그렇게 작동하며, 종종 이해하고 해결하기 어려운 오류로 인해 방해를 받을 수 있어요. 해결책을 찾을 때는 다양한 런타임 및 이들의 비동기 스타일을 기반으로 필터링해야 해요. 비동기 라이브러리를 사용하고 싶으세요? 특정 비동기 런타임 외에서 사용할 수 없는 가능성이 있어요.



두 10년 이상의 JavaScript 경험에 Go 언어로 우수한 경험이 있는 만큼, Rust에서 가장 큰 단점이자 괴로움의 원천은 비동기 처리와 관련된 부분일 것입니다. 극복할 수 있는 문제이지만, 비동기 처리 기능이 필요할 때 항상 준비돼 있어야 합니다. 다른 언어들에서는 비동기 처리가 거의 눈에 띄지 않는데, Rust에서는 그렇지 않습니다.

# 까다로운 부분

## 리팩터링은 지루할 수 있습니다

Rust의 풍부한 유형 시스템은 축복이자 저주입니다. Rust 유형으로 생각하는 것은 꿈같은 경험이 될 수 있습니다. 그러나 Rust의 유형 관리는 악몽이 될 수 있습니다. 데이터와 함수 시그니처에는 일반 유형, 일반 수명 및 특성 제약사항이 포함될 수 있습니다. 이러한 제약 조건에는 고유의 일반 유형 및 수명이 포함될 수 있습니다. 때로는 실제 코드보다 유형 제약이 더 많을 수도 있습니다.




![이미지](/assets/img/2024-05-12-WasRustWorthIt_3.png)

첫 번째로 작성할 때 일일히 제네릭을 모두 정의해야 합니다. 처음에 쓸 때는 지루하지만 리팩토링할 때는 작은 변경도 연쇄적인 문제로 이어질 수 있습니다.

![이미지](/assets/img/2024-05-12-WasRustWorthIt_4.png)

하나의 작업을 진행하기 전에 14개의 다른 정의를 조정해야 한다면 빠른 진전을 이루기 어려울 것입니다.



이해해 줘서 고마워요! 의견에 대해 수정한 내용을 적용했습니다.

# 결론

러스트를 좋아해요. 무엇이든 할 수 있고 다재다능한 모습을 사랑합니다. CLI 앱, 웹 서버 및 웹 클라이언트를 동일한 언어로 작성할 수 있습니다. 웹어셈블리를 사용하면 브라우저에서도 LLM을 실행할 때와 동일한 이진 파일을 사용할 수 있습니다. 이것이 여전히 제 머릿속을 뒤흔들어요.

러스트 프로그램이 얼마나 견고한지 사랑합니다. 러스트가 보호해주는 것들을 깨달은 후에는 다른 언어로 돌아가기 힘들어요. 잠시 동안 Go로 돌아갔다가 빠른 개발 속도에 다시 빠지게 되었어요. 그리고 런타임 패닉이 발생하고 유리가 깨지더라구요.



하지만 러스트에는 문제점이 있어요. 채용이 어렵고 배우는 데 시간이 오래 걸리며 빠르게 반복할 수 없을 정도로 엄격해요. 특히 async 코드를 다룰 때 메모리 및 성능 문제를 해결하는 게 어렵죠. 모든 라이브러리가 안전한 코드에 대해 동일하게 좋지는 않고, 개발 도구도 많이 부족해요. 시작할 때 어려움이 많고 다른 것들도 많이 방해하겠지만, 그 장애물을 극복하면 모두를 앞지를 수 있을 거예요. 하지만 이건 커다란 가정이에요.

우리에게 러스트는 가치가 있었을까요? 아직 일러본도 못했어요. 작은 팀으로 놀라운 일을 해냈지만 방해요소도 많았죠. 러스트를 더 적합하게 만든 기술적 이유도 있었어요.

당신에게는 가치가 있을까요? 빠르게 반복해야 한다면 아마 그렇지 않을 거예요. 알려진 범위가 있거나 초기 비용을 조금 더 감당할 수 있다면? 분명히 고려해보세요. 견고한 소프트웨어를 만들 수 있을 거예요. 매월 더 강해지는 WebAssembly 각도로 봤을 때, 한 번 완벽한 소프트웨어를 작성하고 어디서든 재사용하는 전망이 더 빨리 현실이 될 것 같아요.