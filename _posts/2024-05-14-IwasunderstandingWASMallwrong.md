---
title: "WASM을 전혀 잘못 이해하고 있었어요 "
description: ""
coverImage: "/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png"
date: 2024-05-14 12:24
ogImage: 
  url: /assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png
tag: Tech
originalTitle: "I was understanding WASM all wrong! 🤯"
link: "https://medium.com/@yujiisobe/i-was-understanding-wasm-all-wrong-e4bcab8d077c"
---


# 요약

- WASM은 프론트엔드와 백엔드 모두에 적합하며 브라우저에서 JavaScript의 실행 속도를 높이는 데 사용됩니다.
- 백엔드에서의 WASM은 외부 함수 인터페이스(FFI)와는 다르게 작동합니다. WASM은 빠르고 효율적으로 실행되도록 설계되었습니다.
- WASM의 속도는 저수준 이진 형식, 간단한 메모리 모델 및 미리 컴파일된 특성에서 나옵니다. 이는 오버헤드를 최소화하여 네이티브 코드와 유사한 성능을 제공합니다.
- 저는 Rust와 WASM을 사용하여 wa-ulid에서 ULID 생성을 최적화했습니다. 그 결과 JavaScript 버전보다 40배 빨랐습니다.
- 현재 WASM 파일은 JavaScript보다 크기가 크기 때문에 도전적일 수 있습니다. 그러나 WASM 툴체인과 최적화 기술이 개선됨에 따라, WASM은 백엔드 및 프론트엔드 애플리케이션에 더욱 실용적일 것입니다.

# 소개

개발자로서 저는 종종 Gartner Hype Cycle과 유사한 새로운 기술을 탐험하는 단계를 거치곤 합니다. 이 주기는 새로운 기술을 채택하는 일반적인 경로를 보여줍니다. 이 글에서는 WASM을 통해 백엔드 성능을 향상시키는 방법에 대해 의심에서 호기심으로 변화하는 과정을 설명하고 싶습니다.



![이미지](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_0.png)

WASM은 저수준 명령어 형식입니다. 이는 C, C++, Rust와 같은 언어들의 컴파일 대상으로 설계되었습니다. 주요 목표는 고성능 웹 애플리케이션을 가능하게 하는 것입니다. 그러나 성능이 중요한 경우 서버 측에서도 점점 더 사용되고 있습니다.

내 WASM 여행은 좋은 일과 나쁜 일이 있었습니다. 과대 기대로 시작해서 실망으로 끝났지만 확고한 이해와 실용적인 적용으로 마무리되었습니다.

# 초기 오해들



WASM에 대한 소문을 처음 들었을 때 기대가 컸어요. WASM을 통해 복잡한 계산을 웹 브라우저에 원활하게 통합할 수 있을 것으로 생각했어요. 이것은 FFI가 고수준 언어가 기계 코드를 실행할 수 있도록 하는 방법과 비슷하다고 느꼈어요.

## FFI란 무엇인가요?

FFI는 한 언어의 코드가 다른 언어의 코드를 직접 호출할 수 있게 해줍니다. 성능이 중요하고 로직의 일부가 C 또는 Rust와 같은 저수준 언어로 구현된 경우 사용됩니다. 그 저수준 코드는 그런 후 Python이나 JavaScript와 같은 고수준 언어에서 호출됩니다.

나는 WASM이 FFI와 같은 것으로 여겨, 브라우저에서 기계 수준의 코드를 실행하는 방법일 것이라고 생각했어요. WASM은 고수준 언어를 저수준 바이너리 형식으로 컴파일하기 때문에 이것은 타당했던 것 같아요. 하지만 WASM의 독특한 아키텍처와 제약을 간과하고 있던 거였죠.



## WASM과 FFI 비교

WASM을 FFI로 보았을 때, WASM이 전통적인 기계 코드와 다른 점을 그리워했어요. FFI에서는 종종 호스트 언어와 외부 함수 간 전환 시 주요 오버헤드가 발생합니다. 서로 다른 메모리 레이아웃 간 데이터 이동 또한 비용이 많이 듭니다.

# 현실 확인

WASM을 더 탐험하면서, 처음 기대와 실제 사용 간의 차이를 볼 수 있었어요.



## WASM과 Rust로의 첫 걸음

나는 WASM을 실험하기 시작했고, wasm-bindgen이라는 도구를 사용했다. 이 도구는 WASM 모듈과 JavaScript가 함께 작동할 수 있도록 도와준다. 나의 첫 예제는 간단했다:

```js
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: u32, b: u32) -> u32 {
  a + b
}
```

Link-time optimization (LTO)을 사용하여 wasm-pack을 이용하면, 이 기본적인 덧셈 함수가 작은 214바이트의 WASM 모듈로 컴파일된다. 처음에는 이로 인해 WASM이 간결하고 효율적인 코드를 제공할 수 있다는 것을 입증한 것으로 여겨졌다.



## WAT 형식 알아보기

이 작은 코드 조각이 어떻게 작동하는지 더 잘 이해하기 위해, WAT(WebAssembly 텍스트 형식) 버전을 살펴보았습니다. WAT는 WASM 이진 코드의 가독성 있는 버전입니다. WASM 애플리케이션을 디버깅하고 최적화하는 데 필수적입니다. 'add' 함수의 WAT는 다음과 같습니다:

```js
(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func (;0;) (type 0) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  (memory (;0;) 17)
  (export "memory" (memory 0))
  (export "add" (func 0)))
```

이 간결한 형식은 WASM의 간단한 계산 작업에 대한 효율성을 보여줍니다 — 여분의 오버헤드가 없고, 함수를 수행하는 핵심 연산만 있습니다.



## 복잡성 추가의 영향

나는 그 예시를 수정하여 문자열 작업을 추가하여 모듈 크기에 미치는 영향을 살펴보았습니다:

```js
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: u32, b: u32) -> u32 {
    let a = a.to_string().parse::<u32>().unwrap();
    let b = b.to_string().parse::<u32>().unwrap();
    return a + b;
}
```

똑같은 계산을 하지만, 이 버전은 훨씬 더 큰 14.5KB의 WASM 모듈을 생성했습니다. WAT 파일은 7,126줄 이상으로 늘어나며, 문자열 처리의 추가 복잡성과 오버헤드를 반영했습니다.



![2024-05-14-IwasunderstandingWASMallwrong_1.png](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_1.png)

웹어셈블리( WebAssembly) 인스턴스 생성자는 4KB 미만의 모듈만 동기적으로 컴파일할 수 있습니다. 더 큰 모듈은 비동기적으로 컴파일해야 합니다. 하지만 그 한도 이내로 WASM 파일을 유지하는 것은 불가능한 것 같았어요.

# 환상의 깨달음

문자열 조작과 같은 기능을 추가하면 WASM 모듈의 크기가 급격하게 증가하는 것이 큰 과제였습니다. 파일 크기의 급증은 WASM이 경량이고 효율적인 형식으로서의 약속과 상반됐어요.



## WASM 모듈 크기 최적화

이러한 문제를 해결하기 위해 WASM 모듈 크기를 최적화하는 방법을 탐색했습니다. 다음은 WASM 애플리케이션의 크기를 최소화하기 위한 몇 가지 전략입니다:

- 패닉 회피하기: Rust의 패닉 처리는 오버헤드를 추가합니다. `Option` 및 `Result` 유형을 사용하여 오류를 효율적으로 처리하고 패닉의 부풀어 오름을 피합니다.
- 문자열 사용 제한: 동적 문자열 작업은 WASM 모듈 크기를 크게 불리울 수 있습니다. 정수 또는 고정 크기 데이터 유형을 사용하여 모듈을 간결하게 유지합니다.
- 링크-시간 최적화 (LTO): Rust 컴파일러에서 LTO를 활성화하면 사용되지 않는 코드를 제거하고 크레이트 경계를 효율적으로 최적화하여 컴파일된 WASM 크기를 줄일 수 있습니다.
- 수동 트리 셰이킹: Rust-to-WASM 파이프라인에서 자동 트리 셰이킹이 제한되지만, 필요한 함수 및 종속성만 포함되도록 수동으로 확인하여 부풀림을 줄입니다.

이러한 노력에도 불구하고 때로는 복잡한 데이터 유형 및 고수준 프로그래밍 작업에서 흔히 발생하는 작업으로 인해 극복하기 어려운 과제가 있었습니다.



## 웹어셈블리(WASM)에서 동적 언어

WASM의 난점은 러스트에만 해당하는 것은 아닙니다. 특히 파이썬과 같은 동적 언어는 더 큰 어려움을 겪습니다. 왜 그런지 살펴보려면 동적 언어를 WASM으로 컴파일하는 것을 고려해보세요:

- 인터프리터 컴파일: 파이썬의 경우, 사용자의 코드뿐만 아니라 전체 인터프리터를 WASM으로 컴파일해야 합니다. 이는 언어가 지원하는 모든 내장 함수와 라이브러리를 포함합니다.
- 코드 실행: WASM으로 컴파일된 파이썬 코드를 실행하려면 인터프리터 내에서 인터프리터를 실행해야 합니다. 이는 상당한 오버헤드를 발생시키며 큰 WASM 이진 파일을 만들 수 있습니다.



고도 정적 타입 컴파일 언어인 Go의 경우에도, 최소 WASM 파일 크기는 Go 프로그래밍 언어 위키에 따르면 2MB입니다.

## 커뮤니티 도전 과제

나는 다른 개발자 커뮤니티와 같이 저의 환멸을 겪었습니다. 많은 기사들이 유사한 어려움을 논의했습니다:

- Zaplib 사후 분석: 이는 성능 향상 부족 및 개발 복잡성으로 인해 WASM을 버리기로 한 스타트업의 선택을 자세히 다룹니다.
- 나무 흔들기, 식물학적으로 오류가 있는 알고리즘: 이는 WASM 도구 체인에서 나무 흔들기의 미숙함을 강조하며, 사용하지 않는 코드를 제거하여 최종 바이너리 크기를 줄이는 중요한 프로세스를 강조합니다.



이 커뮤니티 경험들은 현재의 WASM을 사용하는 데 어려움을 겪는 것을 강조하며 처음에 느꼈던 흥분을 식게 만드는 반대 의견을 제공했습니다.

# 변화의 시작

WASM에 대한 실망을 극복하면서, Uber에서 개발한 h3 라이브러리를 찾았을 때 판별적인 순간이 찾아왔습니다. 이 라이브러리는 여러 언어(C, Python, Java, JavaScript)로 구현된 버전을 포함하고 있으며, h3-js는 C에서 컴파일된 WASM을 사용하는 JavaScript와 WASM을 연결하기 위해 Emscripten을 사용합니다.

## h3 이해하기



h3는 지리 공간 색인을 위해 설계되었습니다. 이는 좌표를 육각형 그리드에 색인화하는 방법을 제공합니다. 이 시스템은 대규모 지리 공간 데이터셋을 가진 애플리케이션에 특히 유용합니다. 저는 자주 쓰는 한 가지 함수는 `latLngToCell`인데, 이 함수는 위도와 경도 좌표를 육각형 그리드 셀 식별자로 변환해줍니다.

## 성능 비교

h3-js의 성능을 측정하기 위해 C 구현과 JavaScript 버전을 WASM을 사용하여 벤치마크했습니다. 다행히, 두 레포지토리에 이미 벤치마킹 프로그램이 포함되어 있었습니다. 여기 내 로컬 M1 MacBookPro에서의 결과입니다:

# WASM의 기능 탐색



의완 놀라운 h3-js 결과에 영감을 받아 WASM의 능력을 더 파헤치기로 결정했어요. Collatz 추측을 사용하여 JavaScript와 FFI의 성능을 비교해봤어요.

## Collatz 추측이란?

Collatz 추측은 “3n + 1 문제"로 알려진 수학적 가설로, 다음과 같이 정의된 순서를 포함합니다:

- 양의 정수 n으로 시작합니다.
- 만약 n이 짝수이면 2로 나눕니다.
- 만약 n이 홀수이면 3을 곱하고 1을 더합니다.
- n이 1이 될 때까지 이 과정을 반복합니다.



![Image](/assets/img/2024-05-14-IwasunderstandingWASMallwrong_3.png)  

가설은 시작하는 n 값이 무엇이든, 시퀀스는 항상 결국 1에 도달한다고 주장합니다.

## JS, FFI 및 WASM에서 Collatz 가설

성능을 비교하기 위해 가설을 순수 JavaScript로 구현했고, Rust 함수를 호출하기 위해 FFI를 사용했으며 WASM에서 직접 구현했습니다. 그리고 입력값으로 n = 670617279을 사용했는데, 이는 1에 도달하는 데 986단계가 필요합니다.



- JavaScript

```js
function collatzSteps(n) {
    let counter = 0;
    while (n !== 1) {
      if (n % 2 === 0) {
        n /= 2;
      } else {
        n = 3 * n + 1;
      }
      counter++;
    }
    return counter;
  }
```

- Rust (FFI) and Rust (WASM)

```js
pub fn collatz_steps(mut n: u64) -> u64 {
    let mut counter = 0;
    while n != 1 {
      if n % 2 == 0 {
        n /= 2;
      } else {
        n = 3 * n + 1;
      }
      counter += 1;
    }
    return counter;
  }
```



더 많은 세부 정보를 원하시면 제 리포지토리를 확인해주세요. 다음은 M1 MacBook Pro와 관련한 벤치마크입니다:

이러한 결과는 WASM이 연산 집중적인 작업에 특히 네이티브 JavaScript 및 FFI보다 우월한 성능을 보일 수 있다는 것을 입증했습니다.

# WASM 성능에 대한 깊은 탐구

h3-js와 콜라츠 추측에서의 WASM의 뛰어난 성능을 보고 나니, WASM에 대해 처음에 이해한 것 이상의 가능성이 있다는 것이 분명해졌습니다.



## WASM이 FFI와 다른 점

WASM의 효율성을 이해하는 핵심은 낮은 수준의 이진 명령 형식으로 설계된 것에 있습니다. 이것은 플랫폼에 의존하지 않을 뿐만 아니라 실행 속도와 조밀성을 최적화했습니다. 이는 FFI와 달리 높은 오버헤드가 발생할 수 있는데, 이는 실행 컨텍스트 간 데이터 매샬링과 다른 메모리 모델 처리로 인해 발생할 수 있습니다. 이 구성은 다음을 통해 일반적인 FFI 오버헤드를 최소화합니다:

- 메모리 관리가 직선적이고 일관적임: WASM은 단일 연속 메모리 블록을 사용하여 호스트 환경과의 인터페이스를 단순하게 만듭니다. 이는 전통적인 FFI 환경에서 메모리 관리와 관련된 비용을 줄입니다.
- 실행에 최적화된 이진 형식: WASM 이진 형식은 현대 JIT(Just-In-Time) 컴파일러에 의해 효율적으로 디코딩 및 실행되도록 설계되었습니다. 이는 일반적인 런타임 해석 벌칙을 따르지 않아도 네이티브 기계 코드 속도에 근접한 성능을 제공합니다.

## WASM의 백엔드 사용 사례



h3-js 라이브러리 조사 결과와 내 Collatz 추측 실험으로 인해 WASM의 응용 프로그램 랜드스케이프에 대한 시각이 변화했습니다:

- Frontend보다 Backend: WASM은 초반에는 웹 애플리케이션 잠재력으로 알려졌지만, 그 강점은 특히 백엔드 및 브라우저 이외의 환경에서 데이터 처리, 과학적 계산 및 실시간 미디어 인코딩/디코딩과 같은 공통 계산 중심 환경에서 두드러집니다.
- Edge Computing: WASM은 엣지 컴퓨팅 애플리케이션에 이상적으로 적합하며, 데이터 소스 근처에서 코드를 실행함으로써 응답 시간을 크게 개선하고 대역폭 사용량을 줄일 수 있습니다.

# WASM을 활용한 ULID 생성 최적화

WASM의 성능을 활용한 실용적인 응용 프로그램 중 하나는 Universally Unique Lexicographically Sortable Identifiers (ULID)를 생성하는 것입니다. ULID는 UUID와 유사한 목적을 가지고 있지만 정렬 가능합니다. 타임스탬프와 무작위 구성 요소로 구성되어 있으며, 고유성과 사전식 정렬 가능성을 보장하기 위해 인코딩되어 있습니다. 이로 인해 정렬 순서와 고유성이 중요한 분산 시스템에서 특히 유용합니다.



## 40배 성능 향상

기존 JavaScript ULID 생성 구현을 Rust로 변환하여 WASM으로 컴파일했더니, 상당한 성능 향상을 이뤘습니다. 원래 JavaScript 버전보다 약 40배 빠릅니다.

이 초기 번역은 간단했지만, 성능을 더 최적화하기 위해 섬세한 방법이 이어졌습니다.

## 이후 최적화



먼저, 성능 향상은 초기에 약 10배 빨라졌습니다. 그러나 러스트 구현에서 여러 최적화를 통해 이를 40배로 높였습니다. 이 높은 성능 향상에 기여한 주요 기술들은 WASM에 특정되지는 않지만 다음과 같습니다:

1. 효율적인 데이터 구조 사용

구현에 사용되는 데이터 구조를 최적화하는 것, 즉 동적으로 크기를 조절하는 대신 미리 할당 용량을 갖춘 벡터와 같은 데이터 구조를 사용하는 것은 메모리 할당을 최소화하고 성능이 빈번한 메모리 작업에 의해 방해받지 않도록 보장했습니다.

```rust
// 이전
String::new();
// 이후
String::with_capacity(len);
```



2. 불필요한 변환과 메모리 할당 피하기

원래의 러스트 구현은 계산 비용이 많이 드는 문자열 및 문자 변환을 포함했습니다. 데이터 처리 방식을 최적화하고 메모리 할당을 줄이는 것으로 성능이 크게 향상되었습니다. 예를 들어, 가능한 경우에 문자열이나 문자로 변환하는 대신 직접 바이트 배열을 사용하는 것이 오버헤드를 줄이는 데 도움이 되었습니다.

```js
// 이전
const ENCODING: &str = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
...
let mut chars = Vec::with_capacity(len);
for index in 0..len {
    chars.push(ENCODING.chars().nth(index).unwrap());
}

// 이후
const ENCODING: &str = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
const ENCODING_BYTES: &[u8] = ENCODING.as_bytes();
...
let mut chars = Vec::with_capacity(len);
for index in 0..len {
    chars.push(ENCODING_BYTES[index] as char);
}
```



함수 호출간에 반복적으로 사용되는 값, 예를 들어 인코딩 길이의 제곱과 같은 값을 미리 계산하고 캐싱함으로써 계산 부하를 크게 줄였습니다. 이는 `decode_time`과 같은 함수에 특히 효과적이었습니다. 이 함수들은 반복적이고 예측 가능한 작업들이 많았기 때문이죠.

```js
// Before
const ENCODING_LEN: usize = 32;
const TIME_LEN: usize = 10;
...
for i in 0..TIME_LEN {
    time += i as f64 * (ENCODING_LEN as u64).pow(index as u32) as f64;
}

// After
const ENCODING_LEN: usize = 32;
const POWERS: [f64; 10] = [1.0, 32.0, ..., 35184372088832.0];
...
for i in 0..TIME_LEN {
    time += i as f64 * POWERS[index];
}
```

# 결론

WASM을 활용한 ULID 생성의 최적화는 WASM의 성능을 이해하고 활용함으로써 실제 응용 프로그램에서 상당한 성능 향상을 이끌어냈습니다. 이 사례 연구는 성능과 효율이 중요한 백엔드 시스템 뿐만 아니라 웹에서도 툴체인이 발전함에 따라 WASM이 효과적으로 활용될 수 있는 한 예입니다.



현재, 대규모 이진 크기의 문제로 WASM 사용이 프론트엔드 애플리케이션에서 다운로드 및 실행 속도가 중요한 경우에 제한되는 도전 과제가 있습니다. 그러나 이는 영구적인 제한이 아니라 현재의 장애물입니다. WASM 툴체인이 트리 쉐이킹 및 바이너리 출력 최적화와 같은 기술에서 더 발전함에 따라 이진 크기가 크게 축소될 것으로 예상됩니다.

웹에서의 WASM의 미래는 밝습니다. 툴체인이 발전하고 더 작고 효율적인 바이너리를 생성하는 능력을 향상함에 따라 WASM은 웹 성능과 기능을 혁신할 잠재력이 커집니다. 이것은 백엔드 애플리케이션을 향상시키는 것뿐만 아니라 복잡한 애플리케이션이 브라우저 환경에서 배포되고 실행되는 방식을 철저히 변화시킬 수 있어, 원시 환경과 동등하게 효율적이고 강력하게 만들 수 있습니다.