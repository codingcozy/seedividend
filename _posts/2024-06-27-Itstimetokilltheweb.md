---
title: "웹을 죽여야 할 때가 왔습니다 2024 최신 트렌드 분석"
description: ""
coverImage: "/assets/img/2024-06-27-Itstimetokilltheweb_0.png"
date: 2024-06-27 14:25
ogImage: 
  url: /assets/img/2024-06-27-Itstimetokilltheweb_0.png
tag: Tech
originalTitle: "It’s time to kill the web"
link: "https://medium.com/mike-hearn/its-time-to-kill-the-web-974a9fe80c89"
---


무슨 일이 벌어지고 있어요. 사람들이 불만스러워하는 모양이에요. 시민 불안의 유령이 우리 프로그래밍 커뮤니티를 쫓고 있어요.

처음으로, 많은 개발자들이 웹 플랫폼을 공개적으로 의심하고 있어요. 여기 한 편의 대표적인 기사와 토론이 있어요. 또 다른 것도 있어요. 더 있지만, 당신이 이것을 읽고 있는 만큼 프로그래밍에 흥미가 있는 분이라면, 올해에 대한 현대 웹 개발 상태에 대한 웃기는 항의 한 편은 이미 한 편 이상 읽었어요. 이 기사는 그러한 종류가 아니에요. 저는 상태 quo를 조롱하는 것보다, 매일 그것을 경험하는 불쌍한 사람들보다 더 나은 일을 할 수 없어요. 이 기사는 다른 종류에요.

![이미지](/assets/img/2024-06-27-Itstimetokilltheweb_0.png)

웹을 대체하고 흡수하여 최종적으로 그것을 대체할 만한 경쟁 프로그램을 만드는 방법에 대해 생각해보고 싶어요, 적어도 앱 작성 목적으로요. 웹은 문서를 배포하는 방법으로서도 문제점이 있지만, 걱정할 정도로 심각하지는 않아요.

<div class="content-ad"></div>

이 글은 총 세 편으로 나뉩니다. 첫 번째 편에서는 웹 플랫폼에 대한 심각하고 수정할 수 없는 문제점을 검토할 것입니다. 나는 당신에게 이것을 완전히 폐기해야 한다고 설득하고 싶어요. 결국, 문제를 분석하지 않으면 해결할 수 없거든요. 또한 이 문제들에 대해 이제 정치적으로 이야기할 수 있는 이유를 간단히 살펴보겠어요. 비록 이러한 문제들이 사실 새로운 것은 아니지만 말이에요.

제 2부와 3부에서는 작은 그룹이 합리적인 시간 내에 구축할 수 있는 새로운 앱 플랫폼을 제안하고, 오늘날의 것보다 훨씬 나은 것이어야 한다고 생각해요 (제 의견). 물론, 모두가 마지막 부분에 동의할 수는 없을 거에요. 문제에 동의하는 것은 해결책에 동의하는 것보다 항상 쉽거든요.

제 1부. 시작합니다.

# 왜 웹은 죽어야 할까요

<div class="content-ad"></div>

웹 앱들. 그겟서요? 뭐든 문제가 많지만, 오늘은 두 가지만 얘기해볼게요.

- 웹 개발은 천천히 1990년대를 되살리고 있죠.
- 웹 앱들을 보안하는 건 불가능해요.

요즘 핫한 Facebook의 최신 웹 프레임워크인 Flux에 관한 좋은 블로그 포스트가 있어요. 저자는 Flux가 1985년 발매된 Windows 1.0에서 사용된 프로그래밍 모델을 재현했다고 언급했어요. 마이크로소프트는 이 모델을 사용했는데, 그 당시 컴퓨터가 매우 느려서 적합했지만 개발하기가 어색했죠. 그래서 10년 미만이 지난 시간 동안, 이러한 WndProc 메시징 시스템을 추상화한 제품들(예: OWL)이 생겨났어요.

React/Flux가 사용하는 방식이 이러한 이유 중 하나는 웹 렌더링 엔진이 매우 느리기 때문이에요. 사용자가 실제로 보는 최종 결과물은 20년 전의 Windows 사용자가 본 것보다 약간 더 멋있을 뿐이라는 사실이 있답니다.

<div class="content-ad"></div>

<img src="/assets/img/2024-06-27-Itstimetokilltheweb_1.png" />

지금은 화면 해상도가 높아졌죠. 우리가 좋아하는 회색 음영도 바뀌었어요. 하지만 위에서 보는 UI는 아래에서 보는 UI와 복잡성 면에서 비슷합니다:

<img src="/assets/img/2024-06-27-Itstimetokilltheweb_2.png" />

아이콘 스타일도 똑같아요! Windows 98는 예전에는 다채롭고 빽빽한 픽셀 아트 스타일이었던 플랫, 회색조 아이콘의 새로운 트렌드를 소개했습니다.

<div class="content-ad"></div>

하지만 오피스 2000은 75 Mhz CPU와 32mb RAM으로도 행복했지만, 위에 표시된 구글 독스는 2.5Ghz CPU와 거의 정확히 10배 더 많은 RAM을 사용하고 있어요.

만약 생산성이나 기능이 10배 증가했다면 용서해도 될지도 모르지만, 사실은 그렇지 않아요. 1995년 개발자 플랫폼은 모두 이런 것들을 가져야 했어요. 이것이 '시작의 가치'였어요:

- 레이아웃 제약 조건과 데이터 바인딩이 있는 시각적 UI 디자이너.
- 다국어 소프트웨어 컴포넌트에 대한 정교한 지원. 정적으로 입력된 네이티브 코드와 스크립팅 언어를 혼합할 수 있었어요.
- 몇 메가바이트의 RAM에서 실행될 수 있는 효율적인 출력 바이너리.
- 데이터 그래픽, 테마, 3D 그래픽, 소켓 프로그래밍, 대화식 디버깅을 지원하는 것.

이러한 기능 중 많은 것들이 지난 몇 년 동안에야 웹 플랫폼에 도입되었으며, 종종 불안정한 방식으로 도입되곤 했어요. 웹 앱은 실제 소켓을 사용할 수 없기 때문에 서버를 "웹 소켓"을 지원하도록 변경해야 합니다. UI 구성 요소와 같은 기본적인 것들조차도 끔찍한 상황입니다. 언급할 가치가 있는 웹 IDE는 없으며, 서로 다른 프로그래밍 언어를 혼합하는 것에 대해서는... 자바스크립트로 변환할 수 있어요. 때때로요.

<div class="content-ad"></div>

웹 앱을 개발자가 쓰는 이유 중 하나는 웹에서의 사용자 기대치가 극히 낮기 때문입니다. Windows 95용 앱은 아이콘, 드래그 앤 듭, 되돌리기, 파일 연관, 일관된 키보드 단축키, 백그라운드에서 유용한 작업을 수행하며 오프라인에서도 작동하는 것이 기본 기능으로 예상되었습니다. 하지만 이 모든 것들은 기본적인 앱 수준에 불과했습니다. 정말 인상적인 소프트웨어는 Office 문서 내에 임베드될 수 있거나 Explorer를 확장하거나 원래 개발자에게 알려지지 않은 임의의 플러그인으로 확장되어야 했습니다. 그러나 웹 앱은 보통 이러한 것들을 하지 않습니다.

이 모든 것들이 쌓여 나에게는 데스크톱 앱을 작성할 때 훨씬 더 생산적인 느낌이 듭니다 (파일 유형용 아이콘을 만드는 것과 같은 "세금"을 지불해야 하는 것들을 포함하여도). 또한 사용하는 것을 선호합니다. 그리고 다른 이들과의 토론을 통해 나만 이런 것은 아니라는 것을 압니다.

나는 웹이 이렇게 되어 있는 것은 HTML이 문서 플랫폼으로 시작했을 때 어떤 일관된 디자인 철학과 도구 세트를 갖고 있었기 때문이라고 생각합니다. 그러나 HTML이 앱 플랫폼으로 추상화된 것은 나중에 따로 추가되었고 결국 제대로 이루어지지 않았습니다. 따라서 파일 연관과 같은 기본 기능조차 존재하지 않지만 Google은 행아웃을 만들고 구글의 우선 순위가 무엇이 추가되는지를 결정하기 때문에 HTML5에는 P2P 비디오 스트리밍이 있습니다. 이러한 문제를 피하려면 처음부터 앱을 염두에 두고 설계된 플랫폼이 필요하며, 아마도 그 위에 문서를 추가하는 것이 더 좋을 것입니다.

# 웹 앱은 보안이 불가능합니다

<div class="content-ad"></div>

1990년대 말에 소프트웨어 산업에는 끔찍한 깨달음이 들었습니다: C/C++ 프로그램의 보안 버그는 적 spor한 실수가 아니었고, 임시 프로세스로 처리할 수 있는 것이 아니었습니다. 그것들은 어디에나 있었습니다. 사람들은 C/C++ 조각이 인터넷에 노출되면 악용이 따를 것이라는 것을 깨달았습니다.

그 당시 세상이 얼마나 순진했는지 알 수 있습니다. 2001년 Code Red에 관한 SANS 보고서를 읽어보면 됩니다:

Windows는 자동 업데이트 기능을 가지고 있었지만, 제대로 기본으로 활성화되지는 않았던 것으로 기억합니다. 사용자의 허락 없이 소프트웨어가 변경될 수 있다는 아이디어는 일종의 금기였습니다.

<img src="/assets/img/2024-06-27-Itstimetokilltheweb_3.png" />

<div class="content-ad"></div>

산업은 변화하기 시작했지만, 많은 비명과 부인과 함께였습니다. 당시에는 Linux와 Mac 사용자들 사이에서 이 문제가 Microsoft에만 특정한 문제로 여겨졌다는 것이 일반적인 지혜였죠... 그들의 시스템이 뛰어난 프로그래머들에 의해 만들어졌다는 것. Microsoft는 자신들이 존재적 위기에 직면하고 있다고 받아들였고 "안전한 개발 수명주기"를 도입했습니다(대규모의 교육 및 프로세스 프로그램). 그러나 경쟁사들은 거의 아무것도 하지 않았습니다. 레드먼드는 Windows XP에 방화벽을 추가하고 코드 서명 인증을 도입했습니다. 모바일 코드가 제한되었고, 보안 버그가 끝없는 것으로 드러나자 "패치 화요일"이 고안되었습니다. 영리한 해커들은 예전에 무해로 여겨졌던 버그 유형이 여전히 악용 가능하며, 강력하다고 여겨졌던 악용 방지가 우회될 수 있음을 지속적으로 발견했습니다. Mac 및 Linux 커뮤니티는 천천히 바이러스와 악용에 완전히 면역이 아니라는 사실을 깨달았습니다.

2008년 구글이 Chrome을 출시하면서 최종적인 전환점이 왔습니다. 이 프로젝트는 거대한 노력을 들여 복잡하지만 완전히 투명한 렌더러 샌드박스를 도입한 점이 주목할 만합니다. 다시 말해, 산업 최고의 엔지니어들이 얼마나 노력해도 안전한 C++ 코드를 쓸 수 없다는 사실을 공개적으로 인정했다는 점입니다. 이 신념과 설계가 사실상의 표준이 되었습니다.

## 이제 웹의 차례입니다

유감스럽게도, 웹은 신뢰할만한 앱의 약속의 땅으로 우릴 이끌어가지 못했습니다. 웹 앱은 호스트 OS로부터 어느 정도 격리되어 있기는 하지만, 앱 자체는 2001년 경의 Windows 코드보다 훨씬 튼튼하지 못합니다. 우리의 레거시 문제를 영구적으로 해결하는 대신, 웹은 오히려 하나의 버퍼 오버플로우 종류를 다른 것으로 대체했습니다. 데스크톱 앱이 "이중 해제", "스택 스매시", "이후 무료 사용" 등과 같은 악용 카테고리를 가지고 있는 것과는 달리, 웹 앱은 이를 해결하고 나서도 자체적으로 유사한 실수를 반복하는 경향이 있었습니다: SQL 인젝션, XSS, XSRF, 헤더 인젝션, MIME 혼란 등입니다.

<div class="content-ad"></div>

간단한 논문으로 이어집니다:

나는 안전한 웹 앱을 작성하는 것이 불가능하다는 주장을 제기합니다.

문제를 극복합시다. 이는 말그대로 모든 웹 앱에 해당하는 것이 아닙니다. 네, 안전한 HTML Hello World를 만들 수 있습니다. 멋지네요.

저는 실제 규모의 웹 앱, 현실적인 조건에서 작성된 것에 대해 이야기하고 있습니다. 이는 가볍게 주장하는 것이 아닙니다. 이것은 제가 Google에서 8년간 지켜본 곳에서 얻은 신념입니다. 거기서 가장 뛰어난 웹 개발자들이 계속해서 취약한 소프트웨어를 배포하는 것을 지켜봤습니다.

<div class="content-ad"></div>

구글 보안팀은 세계에서 가장 우수한 보안팀 중 하나일 수도 있고, 아마도 최고일 수도 있습니다. 그들은 내부 교육 프로그램의 일환으로 사람들이 하는 주요 실수들에 대한 유용한 가이드를 작성했습니다. 데이터를 안전하게 브라우저로 전송하여 표시하는 데 도움이 되는 이들의 조언을 여기에 소개합니다:

이 믿기 힘든 마법과 전설 속의 뭉텅이를 읽으면 항상 웃음이 나옵니다. 농담이어야 할 것 같지만 실제로는 구글의 모든 웹 개발자가 알고 있어야 하는 기본적인 내용입니다. 화면에 데이터를 표시하기 위해 필요한 것뿐입니다.

사실, 위의 모든 방어책을 구현하더라도 작동하지 않을 수 있습니다. HEIST 공격은 웹 플랫폼 자체의 수정할 수 없는 설계 결함을 이용하여 심지어 위의 모든 완화 조치를 채택한 웹 앱에서 데이터를 도난당할 수 있게 합니다. 게임 오버입니다.

정말 그렇지 않습니다! 더 나빠집니다! REST/JSON 엔드포인트를 보호하는 것은 현대 웹 개발자가 이해해야 할 다양한 보안 문제 중 하나뿐입니다. 수십 가지 더 있습니다(여기 흥미로운 예제가 있고 다른 재미있는 것이 있습니다).

<div class="content-ad"></div>

내 경험상 이 모든 덫 중 하나라도 들어본 웹 개발자를 고용하려고 시도하면 실패로 끝나기 마련이며, 이런 덫을 신뢰할 수 있는 방법으로 회피하는 개발자를 고용하는 것은 더욱 어렵습니다. 그래서 결론은 다음과 같습니다: 안전한 웹 앱을 작성하는 방법을 이해하지 못한 웹 개발자를 고용할 수 없다면 안전한 웹 앱을 작성할 수 없습니다.

# 핵심 문제

거의 모든 웹 보안 문제는 몇 가지 주요 설계 문제에서 발생합니다:

- 길이를 명시하지 않은 버퍼
- 문서가 아닌 앱을 위한 설계된 프로토콜
- 동일 출처 정책

<div class="content-ad"></div>

버퍼 크기를 잃어버리는 것은 C 프로그램에서 취약점의 전형적인 원인이며 웹도 똑같은 문제를 가지고 있습니다: XSS와 SQL 인젝션 악용은 코드 버퍼가 시작되고 데이터 버퍼가 끝나는 곳이 어디인지 혼란을 야기하는 것에 기반합니다. 웹은 텍스트 프로토콜과 형식에 완전히 의존하기 때문에 버퍼는 반드시 구문 분석되어 길이를 알아내야 합니다. 이는 피할 수 있는 탈출, 대체 및 기타 문제들의 세계를 열어놓습니다.

해결책: 모든 버퍼는 데이터베이스에서 프론트엔드 서버, 사용자 인터페이스로의 이동 과정에서 길이가 사전에 지정되어야 합니다. 끝을 결정하기 위해 어떤 마법적인 문자열을 스캔해야 하는 필요는 없어야 합니다. 이는 전체 스택에서 이진 프로토콜, 형식 및 UI 논리가 필요하다는 것에 유의해주세요.

HTTP와 HTML은 문서를 위해 디자인되었습니다. Egor Homakov이 SMS 코드 입력 필드 안에 간단히 "../sms"를 입력하여 Authy의 2요소 인증 제품을 파괴할 수 있었던 이유는 Authy와 같은 모든 웹 서비스가 하이퍼텍스트를 위해 디자인된 스택에 기반에 두고 있기 때문입니다. 경로 이동이 유용한 것은 만약 접근하려는 것이 실제 HTML 파일이 들어 있는 디렉토리 세트라면 하는 것입니다, Sir Tim이 의도한 대로. 프로그래밍 API를 "문서"로 제공한다면 경로 이동이 치명적일 수 있습니다.

REST가 XML을 반환했을 때만으로도 충분히 나빴지만 요즘에는 XML이 유행을 타지 않고 웹에서는 대신 JSON을 사용합니다. 이는 실제로 보안 문제에 대해 전체 섹션을 갖고 있는 wiki 페이지가 있는 식으로 설계되어 있어서 매우 나쁘게 디자인된 형식입니다.

<div class="content-ad"></div>

수정: REST를 좋은 아이디어인 것처럼 가정하는 것을 그만두죠. REST는 HTTP를 비틀어서 브라우저의 제약을 우회하기 위해 만들어진 좋은 아이디어가 아니에요. 브라우저까지 변형되어야 할 도구를 다른 용도로 바꾸는 것은 문제가 생길 수밖에 없어요. 이런 접근은 결국 좋은 결말을 가져다주지 않아요. 이전 내용을 고려할 때, 클라이언트/서버 간 통신은 RPC 사용 사례에 특별히 설계된 이진 프로토콜을 사용해야 해요.

동일 출처 정책은 스티븐 킹의 소설에서 나온 것 같은 개발자 경험입니다. 위키에서 인용하자면:

SOP는 넷스케이프가 문서 형식에 코드를 덧붙이면서 생긴 결과입니다. 이것은 실제로 어떤 의미도 갖지 않으며, 무엇보다도 10일 이상의 시간이 주어지지 않는다면 앱 플랫폼을 그렇게 설계하지 않겠죠. 그래도 우리는 자비심을 가지고 있어야 할지도 몰라요. 넷스케이프는 격려되는 시간 압력 속에서 일하는 스타트업이었고, 이미 언급한 대로, 그때는 보안에 대해 생각하는 사람이 별로 없었어요. 10일 코딩 마라톤이 더 심각한 상황을 만들었을 수도 있어요.

우리의 동정을 떠나 SOP는 HEIST 공격의 근간이 되며, HEIST는 실제 웹 앱 거의 모두를 손상시키는 것으로 보이며, 아마 역호환성을 깨지 않고 고칠 수는 없을 겁니다. 이것이 안전한 웹 앱을 작성하는 것이 불가능하다는 하나의 더이유입니다.

<div class="content-ad"></div>

수정 사항: 애플리케이션에는 명확한 식별이 필요하며 보안 토큰을 기본 설정으로 서로 공유해서는 안 됩니다. 서버에 액세스 권한이 없다면 해당 서버로 메시지를 보낼 수 없어야 합니다. 웹을 제외한 모든 플랫폼이 이를 올바르게 처리합니다.

웹에는 보안을 어렵게 만드는 다른 디자인 문제들이 있지만, 위의 예시들만으로도 이를 납득시킬 수 있을 것입니다.

# 결론

HTML 5는 우리 산업에 해를 끼치는 요인입니다. 일부 기능은 잘 처리하지만 다른 앱 플랫폼과 쉽게 맞먹을 수 있는 이점도 있지만, 웹의 핵심적인 디자인 결함들은 대부분 수정할 수 없습니다. 따라서 웹은 모바일에서 패배했습니다: 유기적으로 성장하는 대신 실제로 설계된 경쟁 플랫폼이 나왔을 때, 개발자들은 대부분 네이티브 앱으로 전환하는 것을 선택했습니다. 그러나 모바일 외에는 좋은 대안이 없습니다. 데스크탑과 랩톱에 안전하게 분산할 수 있는, 보안된, 자동 업데이트된 앱을 편리하게 배포할 방법이 절실합니다.

<div class="content-ad"></div>

10년 전에는 이 기사를 쓴다고 사형당했을 겁니다. 지금에도 약간의 불만소리가 예상되지만, 최근에는 웹을 비판하는 것이 사회적으로 수용되는 것이 되었습니다. 그때는 웹이 Flash, Shockwave 및 Java와 같은 다른 독점적 플랫폼과 경쟁하고 있었습니다. 웹은 열려 있었지만 경쟁 플랫폼으로의 생존은 분명하지 않았습니다. 그러나 최종적으로 부활하고 승리하는 이야기는 우리 모두의 감정을 자극하는 계산된 이야기입니다: 열린 것이 폐쇄된 것보다 낫고, 집단 소유권이 독점보다 낫고, 다윗이 골리앗을 이길 수 있다는 것 등입니다. 많은 프로그래머들은 그것에 대해 족속적 충성심을 느끼게 되었습니다. "웹"이라는 단어 앞에 붙이면 급증이었습니다. 매크로미디어 플래시가 실제로 좋을지도 모른다고 제안하면 당신의 게크 카드가 취소될 겁니다.

그러나 시대는 변하고 있습니다. 지금은 웹이 너무 비대해져서 열려있다고 부르는 것은 상당히 의미가 없어졌습니다: 몇 십억 달러를 태우고 싶다면 HTML5를 구현할 수있는 가능성이 없습니다. W3C는 사용자의 요구를 충족시키지 못했으며 지금은 관련이 없어졌습니다. 따라서 구글이나 마이크로소프트에서 일하지 않는 한 웹의 기술적 방향에 의미있는 영향을 미칠 수는 없습니다. 이전에는 닫혀 있던 몇 가지 경쟁 플랫폼도 오픈되었습니다. 그리고 자바스크립트 생태계는 자신의 의미없는 순환의 무게 아래서 붕괴하고 있습니다.

드로잉 보드로 돌아가는 시간입니다. 이제 음료를 가져오고이 시리즈의 다음 기사를 읽어보세요: 웹의 후속편은 무엇인가요?