---
title: "자바스크립트의 해시맵"
description: ""
coverImage: "/assets/img/2024-05-14-HashmapinJavaScript_0.png"
date: 2024-05-14 15:41
ogImage: 
  url: /assets/img/2024-05-14-HashmapinJavaScript_0.png
tag: Tech
originalTitle: "Hashmap in JavaScript"
link: "https://medium.com/@lelianto.eko/hashmap-in-ja-3a5c03a8febc"
---


자바스크립트에서 해시맵(연상 배열 또는 객체라고도 함)은 키-값 쌍을 저장할 수 있는 데이터 구조입니다. 해시맵의 키는 객체와 함수를 포함한 모든 값이 될 수 있고, 값은 모든 데이터 유형이 될 수 있습니다.

자바스크립트에서 해시맵을 생성하고 사용하는 예시:

```js
let map = {};

// 맵에 키-값 쌍 추가
map['key1'] = 'value1';
map['key2'] = 'value2';
map['key3'] = 'value3';

// 키를 사용하여 맵의 값에 접근
console.log(map['key1']); // 결과: "value1"
console.log(map['key2']); // 결과: "value2"
console.log(map['key3']); // 결과: "value3"

// 맵에서 키가 존재하는지 확인
console.log('key1' in map); // 결과: true
console.log('key4' in map); // 결과: false

// 맵에서 키-값 쌍 제거
delete map['key2'];
console.log('key2' in map); // 결과: false
```

이 예시에서 객체 리터럴을 사용하여 해시맵을 생성합니다. 대괄호 표기법을 사용하여 맵에 키-값 쌍을 추가하고 값을 가져올 수 있습니다. in 연산자를 사용하여 키가 맵에 존재하는지 확인하고, delete 연산자를 사용하여 맵에서 키-값 쌍을 제거할 수 있습니다.



해시맵은 JavaScript에서 흔히 사용되며 배열의 요소 발생 빈도를 계산하거나 키를 사용하여 데이터 캐시를 유지하는 등의 작업에 사용됩니다. 이들은 유연하고 효율적이며 데이터를 저장하고 검색하기 위한 간단하고 직관적인 방법을 제공합니다.

JavaScript에서 배열의 요소 발생 빈도를 계산하는데 해시맵을 사용하는 예시:

```js
let array = [1, 2, 3, 2, 1, 3, 4, 4, 5];

let countMap = {};

// 배열을 순회하며 각 요소의 발생 빈도를 계산합니다
array.forEach(element => {
  if (countMap[element] === undefined) {
    countMap[element] = 1;
  } else {
    countMap[element]++;
  }
});

// 각 요소의 발생 빈도를 출력합니다
for (let key in countMap) {
  console.log(`요소 ${key}는 ${countMap[key]}번 발생합니다`);
}
```

이 예시에서는 해시맵 countMap이 생성되어 배열의 각 요소의 개수를 저장합니다. forEach 루프는 배열을 순회하며 각 요소의 개수를 요소를 키로 사용하여 countMap에 업데이트합니다. 마지막으로, for 루프를 사용하여 countMap 내의 각 요소의 개수를 로그합니다.



이 방법은 효율적이고 유연합니다. 모든 데이터 유형의 요소 발생 횟수를 계산하고 특정 요소에 대한 횟수를 상수 시간에 검색할 수 있도록 합니다.

만약 배열의 배열이 있고 내부 배열의 요소 발생 횟수를 세고 싶다면, 중첩 루프를 사용하여 두 배열을 반복하고 hashmap에서 카운트를 업데이트할 수 있습니다.

다음은 예시입니다:

```js
let arrays = [[1, 2, 3], [2, 3, 4], [3, 4, 5]];

let countMap = {};

// 외부 배열과 내부 배열을 반복
arrays.forEach(innerArray => {
  innerArray.forEach(element => {
    if (countMap[element] === undefined) {
      countMap[element] = 1;
    } else {
      countMap[element]++;
    }
  });
});

// 각 요소의 카운트를 출력
for (let key in countMap) {
  console.log(`Element ${key} occurs ${countMap[key]} times`);
}
```



이 예시에서는 countMap이라는 해시맵이 생성되어 각 요소의 개수를 저장합니다. 첫 번째 forEach 루프는 외부 배열을 반복하고, 두 번째 forEach 루프는 각 내부 배열을 반복합니다. 각 요소의 개수는 키로 요소를 사용하여 countMap에 업데이트됩니다. 마지막으로 for 루프를 사용하여 countMap에서 각 요소의 개수를 기록합니다.

# 해시맵 질문을 어렵게 만들 수 있는 요소들

해시맵 질문을 어렵게 만들 수 있는 여러 요소들이 있습니다:

- 복잡성: 해시맵은 복잡한 문제를 해결하는 데 사용될 수 있으며, 문제의 복잡성으로 인해 솔루션을 이해하기 어렵게 만들 수 있습니다.
- 구현 세부사항: 해시맵을 구현하는 다양한 방법이 있으며, 구현 세부사항은 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어 해시 함수의 선택, 충돌 해결 전략 및 메모리 관리는 모두 해시맵의 성능과 동작에 영향을 줄 수 있습니다.
- 성능 교환: 해시맵은 시간 복잡성과 공간 복잡성 사이의 균형을 제공하며, 서로 다른 작업 간의 교환을 이해하는 것이 도전적일 수 있습니다. 예를 들어, 해시맵 작업의 시간 복잡성은 하중 인자(load factor)와 해시맵의 크기에 따라 달라질 수 있으며, 공간 복잡성은 충돌 수와 키와 값의 크기에 따라 달라질 수 있습니다.
- 언어별 차이: 서로 다른 프로그래밍 언어에는 해시맵의 다양한 구현이 있으며, 사용 중인 특정 언어는 질문에 대한 답변에 영향을 줄 수 있습니다. 예를 들어, 일부 언어에는 내장된 해시맵 데이터 구조가 있고, 다른 언어는 그렇지 않을 수 있으며, 일부 언어는 충돌 처리 및 크기 조정을 다루는 다른 방법을 가질 수 있습니다.



일반적으로 해시맵의 기본 원리를 이해하고 서로 다른 구현 사이의 trade-off를 이해하는 것이 해시맵 질문에 정확하고 효과적으로 대답하는 핵심입니다.

자바스크립트에서 해시맵의 기본과 trade-off

- 기본: 해시맵은 키를 값에 매핑하는 데이터 구조인데, 자바스크립트에서는 객체나 Map 객체를 사용하여 해시맵을 구현할 수 있습니다. 객체는 해시맵을 구현하는 간단한 방법이지만 일부 제한이 있습니다. 예를 들어, 키는 반드시 문자열이어야 하고 키는 추가된 순서대로 열거됩니다. Map 객체는 ECMAScript 6에서 도입되었으며 모든 유형의 키를 지원하고 순서가 지정된 반복을 제공하는 더 유연하고 강력한 해시맵 구현을 제공합니다.
- 시간 복잡도: 자바스크립트에서 해시맵 연산의 시간 복잡도는 해시맵의 크기와 키의 분포에 따라 달라집니다. 일반적인 연산인 요소 추가, 요소 찾기 및 요소 삭제는 평균 시간 복잡도 O(1)를 가지며 평균적으로 일정한 시간이 소요됩니다. 그러나 해시맵이 잘못 설계되었거나 키가 고르게 분산되지 않은 경우 시간 복잡도가 저하되어 성능이 저하될 수 있습니다.
- 공간 복잡도: 자바스크립트에서 해시맵의 공간 복잡도는 해시맵에 저장된 요소 수와 키와 값의 크기에 따라 달라집니다. 일반적으로 해시맵은 배열보다 메모리를 더 많이 필요로 합니다. 하지만 키와 값의 크기를 최적화하여 공간 복잡도를 줄일 수 있습니다.
- 충돌: 두 개 이상의 키가 해시맵에서 동일한 인덱스로 매핑될 때 충돌이 발생합니다. 자바스크립트에서는 체이닝(각 인덱스에 연결 리스트 저장)이나 프로빙(충돌 후 빈 슬롯을 찾는)과 같은 다양한 전략을 사용하여 충돌을 해결할 수 있습니다. 충돌 해결 전략의 선택은 해시맵 연산의 시간 및 공간 복잡도에 영향을 미칠 수 있습니다.

요약하면, 해시맵은 키를 기반으로 요소에 빠르게 액세스할 수 있는 강력하고 유연한 데이터 구조이지만 자바스크립트에서 해시맵을 사용할 때 시간과 공간 복잡도 사이의 trade-off와 구현 선택을 고려해야 합니다.