---
title: "12부 setTimeout  클로저 인터뷰 문제 "
description: ""
coverImage: "/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png"
date: 2024-05-12 21:06
ogImage: 
  url: /assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png
tag: Tech
originalTitle: "Part 12: setTimeout + Closures Interview Questions 🤓"
link: "https://medium.com/@swati.developer17/part-12-settimeout-closures-interview-questions-cfa0d402831f"
---


# 사전 준비 사항:

만약 클로저(Closures) 개념이 잘 이해되지 않는다면, 아래 내용을 꼭 읽어보세요:

- Part 11: 자바스크립트(JS)에서의 클로저(Closures) 🤷🏻‍♀️

![이미지](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_0.png)



## 이 프로그램을 실행하면 콘솔에서 무엇을 기대하시나요?

출력:

![Output](/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_1.png)

1초 후에 i의 값인 1이 출력됩니다.



아래와 같이 시간 초가 지난 후 출력이 됩니다.

setTimeout()을 사용하면 3초 후에 i를 출력한 다음 "Learn"을 출력할 것으로 생각할 수 있습니다. 하지만, 그렇지 않습니다. "Learn"을 먼저 출력하고 3초를 기다린 후 i의 값을 출력할 것입니다.

## setTimeout()이 실제로 하는 일은 무엇인가요?

- 3줄에서, function ()이 클로저를 형성합니다. 이 함수는 i에 대한 참조를 기억합니다.
- setTimeout()은 해당 콜백 함수를 실행하고 어딘가에 저장하고 타이머를 부착합니다. JS는 다음 줄로 진행합니다.
- 타이머가 만료되면 해당 함수를 가져와서 호출 스택에 넣고 실행합니다.



다음은 복잡한 문제의 예를 살펴보겠습니다.

## 콘솔에 1부터 10까지의 숫자를 매 초마다 출력하려고 합니다. 즉, 1초 후에 1을, 2초 후에 2를, 그리고 3초 후에 3을 출력하는 방식입니다. 이를 어떻게 해결할 수 있을까요?

첫 번째 떠오르는 해결책은 for 루프를 사용하고 그 안에 setTimeout()을 넣는 것입니다. 아래와 같이 말이죠?

이제 결과를 확인해 보겠습니다:



<img src="/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_2.png" />

이건 우리가 기대했던 것과 다릅니다. 왜 그런 건가요? 무슨 일이 있었나요? 🧐

두 가지 이유가 있어요:

1. 우리는 클로저가 함수와 그 렉시컬 환경이 어떻게 동작하는지 배웠거든. 그래서 함수가 자신의 원래 범위에서 벗어나더라도 여전히 자신의 원래 범위를 기억할 거에요. 클로저는 렉시컬 범위의 변수에 접근할 수 있어요.



그래서 setTimeout()이 이 함수를 취하고 어딘가에 저장하고 타임아웃을 부착하면, i에 대한 참조를 기억합니다.

따라서 루프가 처음 실행될 때, 함수의 복사본을 만들어 타이머를 부착하고 i에 대한 참조를 기억합니다.

마찬가지로, 모든 10개의 함수 복사본은 i에 대한 참조를 기억하고 있으며, 값이 아닙니다. 그리고 모두 같은 i에 대한 참조를 가리키고 있습니다.

## 왜 젠장 같은 i에 대한 참조를 가리키고 있는 걸까요? 😳



모든 이러한 기능들의 환경은 같기 때문이에요. setTimeout()의 콜백 함수 복사본들은 모두 같은 메모리 공간에서 i를 참조하고 있어요. 🤷🏻‍♀️

2. JS는 아무것도 기다리지 않아요. 그래서 루프가 계속 실행될 거예요 🔄. 그래서 setTimeout()은 모든 10개의 함수를 저장하고 JS는 계속 진행할 거예요. JS는 타이머가 만료되기를 기다리지 않아요. "Learn"을 출력하고, 타이머가 만료되면 이미 너무 늦어요. 이제 i의 값이 변경되었어요. 왜냐하면 루프가 계속 실행되었으니까요. 이 콜백 함수가 실행될 때에는 이미 메모리 위치에 var i = 11의 값이 되어 있어요.

그래서 매번 11이 출력되는 거죠 🤷🏻‍♀️. 왜냐하면 이러한 콜백 함수 복사본들이 모두 같은 메모리 위치를 참조하기 때문이에요 🤦🏻‍♀️. 해당 위치는 이제 10번 실행되었고 루프에서 값이 1씩 증가했기 때문에 11이 되었답니다 🙄.

## 이제, 어떻게 이 문제를 해결할 수 있을까요? 💡💡



let 대신 var 대신 사용하세요. 왜냐하면 let은 블록 범위를 가지고 있기 때문에 각각의 반복에서 i는 매번 새로운 변수가 됩니다. 메모리에는 매번 i의 새 복사본이 있습니다. 

setTimeout()이 실행될 때, 콜백 함수는 새로운 i의 복사본을 가질 것입니다. 

실행해보고 결과를 확인해봅시다:

<img src="/assets/img/2024-05-12-Part12setTimeoutClosuresInterviewQuestions_3.png" />

잘 작동했어요 🎉🎉



## 다시 한 번 수정해 봅시다. let 키워드 때문에 실제로 일어난 일에 대해:

1. i = 1로 시작한 루프에서, 함수가 자체적으로 새 변수와 클로저를 형성했습니다.
2. i++ 이후에 함수가 다시 클로저를 형성했을 때, 값이 2인 새 변수를 가지고 있으며 이를 저장했습니다.
3. 이런 식으로 계속 진행됩니다. 이렇게 하면 변수 i의 10개의 복사본을 만들어 각 함수마다 클로저를 형성합니다.

## 그래서, 다음에 누군가 아래 두 경우의 출력 차이와 그 이유에 대해 물으면? 당신은 답을 알고 있습니다 😎

## 경우 1:



```js
function x(){
  for (var i = 1; i <= 10; i++){  // 이 부분에서 var을 사용했어요 
    setTimeout(function (){
    console.log(i);
    }, i * 1000);
  }
  console.log("배워요")
}
x();
```

## Case 2:

```js
function x(){
  for (let i = 1; i <= 10; i++){  // 이 부분에서 let을 사용했어요 
    setTimeout(function (){
    console.log(i);
    }, i * 1000);
  }
  console.log("배워요")
}
x();
```

Answer: let은 블록 스코프이며 루프가 실행될 때마다 매번 새로운 복사본을 생성합니다.



## 다시 뒤로 돌아가기 🤭: 만약 var만 사용하고 매 초 1,2,3,..10을 출력해야 한다면 어떻게 해야 할까요? 

조금만 생각해 보세요. 어떤 해결책이 될 수 있을까요?
요령은 매번 변수 i의 새 복사본을 만들어야 한다는 것입니다.

그래서, 새로운 함수 close()를 만들고 그 안에 setTimeout()을 랩핑합니다. 그리고 호출할 때마다 i를 전달합니다.

## 왜 이 방법이 동작할까요? 😬



매번 i와 함께 close() 함수를 호출할 때마다 setTimeout()을 위한 새로운 i 복사본이 생성된다고 해요 😎.

그게 전부에요. setTimeout()이 어떻게 작동하는지와 클로저랑 어떻게 연관되는지 다루었어요. 👏🏼

## 다음 👩🏻‍🏫 ⏭️ : 제13부 : 클로저 JS 인터뷰 질문들 🤯

이 기사를 읽어 주셔서 감사합니다 ❤️



# ⭐️ 즐겁게 코딩해요. ⭐️

오늘 무엇인가를 배웠으면 좋겠네요! 떠나시기 전에:

- 👏 스와티 레드후를 따르고 스토리에 박수를 보내주세요 👩🏻‍💻
- 📰 2023 자바스크립트 학습 로드맵에서 더 많은 콘텐츠를 확인해보세요 — 최고의 안내서 ❤️
- 🔔 LinkedIn을 팔로우해주세요

🚀👉 자바스크립트 기본을 확실히 다지고 멋진 직장을 찾아보세요