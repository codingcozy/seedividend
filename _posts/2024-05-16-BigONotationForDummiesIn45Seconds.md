---
title: "45초 안에 이해하는 더미를 위한 빅 오 표기법"
description: ""
coverImage: "/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png"
date: 2024-05-16 03:27
ogImage: 
  url: /assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png
tag: Tech
originalTitle: "Big O Notation For Dummies In 45 Seconds"
link: "https://medium.com/@zlliu/big-o-notation-for-dummies-in-45-seconds-9cf9db1b2136"
---


![image](/assets/img/2024-05-16-BigONotationForDummiesIn45Seconds_0.png)

소프트웨어 엔지니어링 직무를 위한 기술 코딩 면접에 도전한다면 이것을 알아야 합니다.

면접관이 당신에게 문제를 해결하는 코드를 작성하라고 요청할 때, 당신이 솔루션을 코딩한 후, 그는 다음과 같은 질문을 할 수 있습니다:

- 당신의 솔루션의 시간 복잡도는 무엇인가요?
- 당신의 솔루션은 얼마나 효율적인가요 (또는 시간 효율적인가요)?
- 당신의 솔루션의 Big O는 무엇인가요?



주의 — 이 모든 질문들은 대략 동일한 내용을 다룹니다.

## 시간 복잡도/시간 효율성의 의미

일반적으로 알고리즘/함수의 시간 복잡도 또는 시간 효율성은 실행 속도를 나타냅니다.

더 구체적으로 말하면, 주어진 입력 크기 N에 대해, 시간 복잡도/시간 효율성은 알고리즘/함수가 실행되기 위해 필요한 일반적인 반복 횟수를 나타냅니다.



# 빅 오 표기법은 일반적으로 시간 복잡성/시간 효율성을 측정하는 데 사용됩니다.

참고 — 우리는 반복의 정확한 횟수에 대해 정확히 신경 쓰지 않습니다. 우리가 신경 쓰는 것은 입력 N이 커질수록 일반적인 반복 횟수가 얼마나 증가하는지입니다.

가장 일반적으로 사용되는 빅 오 시간 복잡성은 다음과 같습니다:

- O(1) → 상수 시간 (가장 시간 효율적)
- O(log n) → 로그 시간
- O(n) → 선형 시간
- O(n²) → 다항식 시간
- O(2^n) → 지수 시간
- O(n!) → 팩토리얼 시간 (가장 시간 효율적이지 않음)



# 이들이 의미하는 것 (일반적으로)

O(1) 또는 상수 시간 (최상의 효율성)

- N이 무엇이든 간에 알고리즘은 항상 1단계를 거침
- N이 1이면 알고리즘은 1단계를 밟음
- N이 10이면 알고리즘은 여전히 1단계를 밟음
- N이 1000이면 알고리즘은 여전히 1단계를 밟음
- 일반적인 사용 사례 — 사전에서 값에 액세스, 단일 작업

O(log n) 또는 로그 시간 (로그의 밑을 2로 가정)



- 반복 횟수는 N에 대해 로그함수적으로 증가합니다.
- N이 4일 때, 우리 알고리즘은 2단계가 걸립니다.
- N이 8일 때, 우리 알고리즘은 3단계가 걸립니다.
- N이 16일 때, 우리 알고리즘은 4단계가 걸립니다.
- N이 32일 때, 우리 알고리즘은 5단계가 걸립니다.
- 일반적인 사용 사례 — 이진 탐색

O(n) 또는 선형 시간

- 반복 횟수는 N에 대해 선형적으로 증가합니다.
- N이 4일 때, 우리 알고리즘은 4단계가 걸립니다.
- N이 8일 때, 우리 알고리즘은 8단계가 걸립니다.
- N이 32일 때, 우리 알고리즘은 32단계가 걸립니다.
- 일반적인 사용 사례 — for 루프를 이용해 리스트를 반복하는 경우

O(n²) 또는 다항 시간



- 반복 횟수는 대략적으로 n²이 됩니다.
- N이 4일 경우, 우리 알고리즘은 16단계가 걸립니다.
- N이 8일 경우, 우리 알고리즘은 64단계가 걸립니다.
- N이 32일 경우, 우리 알고리즘은 1024단계가 걸립니다.
- 일반적인 사용 사례 — 중첩된 for 루프

O(2^n) 또는 지수 시간 (이 효율성이 끔찍해요)

- 반복 횟수는 N과 지수적으로 증가합니다.
- N이 4일 경우, 우리 알고리즘은 2⁴ 단계 걸립니다 (그건 16이에요).
- N이 8일 경우, 우리 알고리즘은 2⁸ 단계 걸립니다 (그건 256이에요).
- N이 32일 경우, 우리 알고리즘은 2³² 단계 걸립니다 (그건 4294967296이에요).
- 알고리즘이 지수 시간이 걸린다면, 효율적인 방법을 찾아보아야 할 수도 있어요.

O(n!) 또는 계승 시간 (절대적으로 효율성이 끔찍해요)



- 반복 횟수는 N에 팩토리얼적으로 증가합니다.
- 만약 N이 4이면, 우리의 알고리즘은 4! 단계를 거칩니다 (24 단계)
- 만약 N이 8이면, 우리의 알고리즘은 8! 단계를 거칩니다 (40320 단계)
- 만약 N이 32이면, 우리의 알고리즘은 32! 단계를 거칩니다 (아주 많은 단계)
- 당신의 알고리즘은 결코 팩토리얼 효율성을 가져서는 안 됩니다.

# 참고 - 여기서는 상수를 무시합니다

우리는 일반적인 반복 횟수에만 관심이 있기 때문에, 상수에 대해서는 그다지 신경쓰지 않습니다. 그런데 이것들이 전체적인 흐름에 큰 영향을 미치지 않기 때문입니다.

- O(1)은 O(2)나 O(20)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(1)을 사용합니다
- O(n)은 O(2n)이나 O(3n)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(n)을 사용합니다
- O(n²)은 O(n³)이나 O(n⁶)과 동일합니다 — 우리는 이들 모두를 나타내기 위해 O(n²)을 사용합니다
- O(2^n)은 O(3^n)이나 O(7^n)과 동일합니다 — 패턴을 알 수 있겠죠?



# 빠른 예시

```python
def test(n):
    return n + 1

# 전체 시간 복잡도: O(1)
```

^ n이 얼마나 커도, 우리 함수는 단지 한 단계를 수행합니다. 즉, 이 함수는 O(1)의 시간 복잡도를 갖습니다.

# 또 다른 예시



```python
def test(n):
    for i in range(n):    # O(n)
        print(i)   # O(1)

# overall time complexity: O(n)
```

여기서는 range(n)을 통해 반복하는 for 루프를 사용하므로 이 for 루프 자체의 시간 복잡도는 O(n)입니다.

print(i) 문 자체는 O(1)입니다. 따라서 O(n)에 O(1)을 곱하더라도 여전히 O(n)이 되며, 전체 시간 복잡도는 O(n)입니다.

# 또 다른 예시




```js
def test(n):
    for i in range(n):      # O(n)
        for j in range(n):  # O(n)
            print(i, j)     # O(1)

# overall time complexity: O(n^2)
```

^ 여기에 중첩된 for 루프가 있습니다. 하나의 for 루프 안에 다른 for 루프가 있습니다.

O(n)이 O(n)에 곱해지면 O(n²)가 되며, 이는 우리 알고리즘의 시간 복잡성을 다항 시간인 O(n²)로 만듭니다.

# 결론



이해하기 쉽고 명확했길 바랍니다

## 제작자로서 저를 지원하고 싶다면

- 이 이야기에 대해 50번 박수를 치세요.
- 생각을 나눠주세요.
- 이야기에서 가장 좋아하는 부분을 강조해주세요.

감사합니다! 이 작은 동작들이 큰 도움이 되고, 정말 감사합니다!



YouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)

LinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)

My Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)