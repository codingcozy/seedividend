---
title: "Next Js 13 프로젝트에서 Redux Tool Kit을 구성해 보세요"
description: ""
coverImage: "/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png"
date: 2024-05-12 21:42
ogImage: 
  url: /assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png
tag: Tech
originalTitle: "Configure Redux Tool Kit in Next Js 13 project."
link: "https://medium.com/@xavierdev16/step-by-step-tutorial-how-to-configure-redux-tool-kit-in-next-js-13-app-3595460d11e5"
---


<img src="/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_0.png" />

안녕하세요! 이 글에서는 Next Js 13 프로젝트에 Redux Tool kit (RTK)을 설정하는 단계별 프로세스를 안내해 드리겠습니다. Redux Tool kit은 React/Next Js 애플리케이션에서 상태를 전역적으로 관리하는 데 도움이 되는 도구 세트입니다. Next Js 13의 릴리스 이후로, Redux Tool kit을 Next 13 앱에 통합하는 데 도움이 되는 문서가 부족합니다. 이 글이 여러분이 읽으면서 기대하는 만족도를 높여드릴 것을 희망합니다.

프로젝트 설정 및 설치

이미 Next 13 프로젝트를 설정했고 상태를 관리하기 위해 redux tool kit을 통합할 준비가 되어 있다고 가정합니다. 만약 제 가정이 틀렸다면, 항상 그런 경우이니까 Next js를 설치하는 방법은 여기를 참조하세요.



Redux 도구 킷을 앱에 통합하기 위해 먼저 필요한 라이브러리를 설치해야 합니다.

```js
// Redux 도구 킷과 리액트 리덕스 설치
npm install @reduxjs/toolkit react-redux
```

Redux 도구 킷과 리액트 리덕스는 앱을 실행시키고 전역 상태를 관리할 준비를 완료하는 데 필요한 라이브러리입니다.

그다음, Next 앱 프로젝트 구조를 설정해야 합니다. src/app 폴더 안에 GlobalRedux라는 새 폴더를 만들고, GlobalRedux 폴더 안에 store.js와 provider.js라는 두 파일을 만들어야 합니다. 또한, 슬라이스에 관련된 모든 파일을 담을 Features라는 폴더를 생성해야 합니다. 간단하고 최소한의 구조를 유지하기 위해 하나의 슬라이스만 생성하겠습니다. 그것을 counterSlice.js라고 이름 짓겠습니다. JavaScript 파일에 확장자로 .jsx 또는 .js 중 하나를 선택할 수 있습니다. 이제 프로젝트 구조는 다음과 같아야 합니다.



<img src="/assets/img/2024-05-12-ConfigureReduxToolKitinNextJs13project_1.png" />

## 슬라이스 구성

슬라이스란 당신의 앱에서 하나의 기능에 대한 Redux 리듀서 로직과 액션들의 모음을 나타냅니다. 일반적으로 한 파일에 정의되어 있습니다. 코드를 자세히 살펴보기 전에 중요한 점을 알려드릴게요. 모든 파일은 클라이언트 측 컴포넌트입니다. 파일의 맨 위에 'use client'를 추가해야 합니다. 이제 방금 만든 각 파일에 코드를 추가해 보겠습니다. 먼저 counterSlice.jsx 파일을 구성해야 합니다. 이 파일은 컴포넌트의 상태를 변경하기 위해 실행해야 하는 코드를 가져옵니다.

```js
//counterSlice.jsx

"use client"; // 이것은 클라이언트 측 컴포넌트입니다.

import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  value: 0,
};

export const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions

export default counterSlice.reducer;
```



위 파일에서는 카운터 버튼을 증가 및 감소하는 논리를 간단히 작성하고 있습니다.

## 저장소 설정

이제 Redux-tool-kit 저장소를 설정해 봅시다. Redux 저장소는 애플리케이션의 모든 상태를 저장하는 중심적인 버킷입니다. 애플리케이션 상태에 대한 단일 진실의 원천으로 고려되고 유지되어야 합니다.

```js
//store.jsx

"use client";
import { combineReducers, configureStore } from "@reduxjs/toolkit";
import counterReducer from "./Features/Counter/counterSlice";


const rootReducer = combineReducers({
  counter: counterReducer,
  // 여기에 모든 리듀서를 추가하세요
}, );

export const store = configureStore({
  reducer: rootReducer,
});
```



저희 store.js가 작동 중이니, 앱에 상태 변화가 전역 변수로 캡처되도록 스토어를 제공해야 합니다. 이것이 대부분의 자습서에서 빠뜨리는 가장 중요한 부분이에요.

## 사용자 지정 프로바이더 구성

Next.js와 Redux 툴킷을 설정할 때, provider.js라는 별도의 파일을 만들어야 합니다. `Provider` 컴포넌트는 Redux 스토어를 Redux 스토어에 액세스해야 하는 중첩된 모든 컴포넌트에 사용할 수 있게 합니다. provider.js 파일을 설정해봅시다.

```js
//provider.js
"use client";
import { Provider } from "react-redux";
import { store } from "./store";

export function Providers({ children }) {
  return <Provider store={store}>{children}</Provider>;
}
```



대부분의 리액트 앱에서 제공 엘리먼트를 직접적으로 Next 애플리케이션의 루트에 감싸지 않는다는 점에 주목하게 될 거예요. 대신 여러분이 만든 별도의 제공자 컴포넌트인 Providers를 생성하고, 이를 애플리케이션의 루트를 감싸기 위해 내보낼 거예요. 이는 이번 경우인 메인 레이아웃인 layout.jsx 파일이 서버 측 렌더링된 컴포넌트이지만, Next.js 제공자 컴포넌트는 클라이언트 측으로 렌더링되어야 하기 때문이에요. 만약 여러분이 이 규칙을 어긴다면 버그가 발생할 수 있으니 참고하세요. 앱을 직접적으로 제공자로 감싸는 것이 아니라 적용하는 것을 시도해보면 문제점을 보실 수 있을 거예요.

## 앱 루트를 제공자로 감싸기

마지막으로, 방금 만든 사용자 지정 제공자 컴포넌트로 앱을 감싸야 합니다. 이 단계도 주의깊게 살펴주세요. 리액트 애플리케이션과 달리, Next.js 13에는 app.js라는 특별한 루트 앱이 없는데요. 그래서 Next 13 앱의 주요 시작점은 여러분의 layout.js 파일입니다. 우리가 만든 사용자 지정 제공자를 가져와서 layout.jsx 파일의 자식 요소들을 감싸게 될 거에요. layout.js 파일의 자식 요소들은 여러분의 앱의 모든 페이지들이라는 뜻이에요. 이제 앱의 모든 상태를 하나의 저장소에서 관리하고 있습니다.

```js
//layout.js
import { Providers } from "./GlobalRedux/provider";
import "./globals.css";
import styles from "./page.module.css";

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};
const RootLayout = ({ children }) => {
  return (
    <html lang="en">
      <head className={styles.header}></head>
      <body>
        {/* 사용자 지정 제공자 컴포넌트를 가져오세요 */}
        <Providers>{children}</Providers>
      </body>
    </html>
  );
};
export default RootLayout;
```



지금까지 계속 참고해 왔다면, 멋진 일을 했어요. 이제 커피 한 잔을 마실 시간이에요.

마지막 단계가 하나 남았어요. 우리 앱에 저장된 상태에 접근하고 만든 컴포넌트 내에서 사용해야 해요. 이를 위해 useDispatch와 selector 훅을 사용할 거에요. react-redux에서 useDispatch 훅은 우리에게 스토어의 디스패치 메소드에 액세스할 수 있게 해줘요. 디스패치는 우리가 리덕스 스토어로 액션을 보내는 데 사용되며 컴포넌트 내에서 스토어에 영향을 주는 유일한 방법이에요. "선택자 함수"는 리덕스 스토어 상태(또는 상태의 일부)를 인수로 받고 그 상태에 기반한 데이터를 반환하는 어떠한 함수라고 할 수 있어요. 말이 많아졌네요, 이제 useDispatch와 selector가 어떻게 사용되어 앱 상태에 액세스할 수 있는지 보겠습니다.

```js
//page.jsx

//기본적으로, 이는 저장된 상태에 액세스하거나 컴포넌트 상태로 스토어를 업데이트하는 방법입니다.

"use client";

import { useDispatch, useSelector } from "react-redux";
import { increment, decrement } from "./GlobalRedux/Features/counter/counterSlice";


export default function Home() {
//useSelector를 통해 스토어로부터 상태 가져오기
  const count = useSelector((state) => state.counter.value); // 카운터 상태에 액세스

//useDispatch는 컴포넌트에서 스토어를 상태로 업데이트하는 데 사용되며, counterslice.js 내에서 정의된 로직에 따라 정의됩니다
  const dispatch = useDispatch();

  return (
    <div>
      <h1>Counter: {count}</h1> {/* 카운터 상태 표시 */}
      <button onClick={() => dispatch(increment())}>증가</button>
      <button onClick={() => dispatch(decrement())}>감소</button>
    </div>
  );
}
```

위 파일에서 우리는 간단히 컴포넌트 내에서 스토어 상태의 값을 가져오고 싶었어요. page.jsx 파일에서 카운터를 생성하고 감소 또는 증가하는 두 개의 버튼을 만들었어요. useSelector 메소드를 사용하여 스토어의 카운터 값에 액세스할 수 있었죠. 사용자가 증가 또는 감소 버튼을 클릭했을 때 우리의 스토어를 업데이트하기 위해, useDispatch 메소드를 실행하여 컨터스라이스.jsx에 정의된 로직을 실행해요. 이 경우에는 간단히 스토어에서 카운터 값을 증가/감소시키는 로직이었습니다.



## 결론

끝까지 참고해 주셔서 축하드립니다. 다음 JS 13 앱에 Redux 툴킷을 설정할 수 있었으면 좋겠네요. 이 글이 마음에 드셨다면 좋아요를 눌러주세요.