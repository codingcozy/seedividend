---
title: "키워드 검색이 모든 것을 해결해줄까"
description: ""
coverImage: "/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png"
date: 2024-07-12 20:41
ogImage:
  url: /assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png
tag: Tech
originalTitle: "Maybe keyword search is all you need"
link: "https://medium.com/@fabio.matricardi/maybe-keyword-search-is-all-you-need-4c1cdedbb3f9"
isUpdated: true
---

![이미지](/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png)

의미 검색이 자연어 강점을 강조하며 주목을 받는 동안, 클래식 키워드 검색은 여전히 가치 있는 도구로 남아 있습니다. Retrieval Augmented Generation이 유명해지거나, 때로는 사용자 의도가 분명하지 않을 수 있기 때문일지도 모릅니다. 이유가 무엇이든 의미 검색만이 인기 있는 주제인 것 같습니다.

정말 그게 그렇게 필요한가요? 모든 시간에 복잡한 검색이 필요한가요?

# 의미 검색과 키워드 검색의 차이점은 무엇인가요?

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

먼저 몇 가지 간단한 정의들을 살펴봐요.

키워드 검색(Keyword Search): 데이터 내에서 특정 키워드나 구에서의 정확한 존재에 의존하는 리터럴 일치 기반 시스템.

의미 검색(Semantic Search): 질의의 의미와 의도를 이해하려고 하는 보다 정교한 방법으로, 단어와 개념 간의 맥락과 관계를 고려합니다.

그래서 의미 검색과 키워드 검색의 주요 차이는 의미 검색이 검색 용어 뒤의 맥락과 의도에 초점을 맞추는 데 반해, 키워드 검색은 검색에 사용된 키워드에 기반하여 검색 기록을 일치시킨다는 것이에요.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

# also a keyword search is all you need

“올드 스쿨” 방식인 키워드 검색이 빛을 발하는 시나리오를 살펴봅시다. 그리고 어떤 유형의 데이터에서 빛을 발하는지 알아봅시다.

1. 정밀함이 최고입니다: 클래식 키워드 검색은 정확히 무엇을 찾고 있는지 알 때 매우 명확한 결과를 제공합니다. 특정 문서 제목이나 정확한 구절이 필요한가요? 적절한 키워드를 목걸이처럼 연결하여 정확성을 확보할 수 있습니다.

2. 간단하고 명확합니다: 이 직관적인 방식은 모호성을 제거합니다. 키워드를 입력하면 해당 키워드를 포함한 결과를 얻습니다. 잘못 해석하거나 의도하지 않은 연상을 피할 수 있어서 법적 연구나 기술 문서 검색과 같은 작업에 이상적입니다.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

3. **속도 악당**: 직접적인 매칭에 의존하기 때문에 클래식 검색 알고리즘은 쿼리를 더 빨리 처리합니다. 이 효율성은 과학 데이터베이스나 금융 거래 플랫폼과 같이 실시간 응답을 필요로 하는 대규모 데이터 세트나 응용 프로그램에 중요합니다.

4. **당신의 통제**: 검색어를 지정하여 예상치 못한 결과에 대한 여지를 남기지 않습니다. 데이터베이스를 키워드로 풍부하게 하는 경우, 검색 기준을 더욱 좁혀 설정할 수 있습니다. 이 통제는 규정 준수나 브랜드 안전 검사와 같이 특정 기준을 엄수해야 하는 작업에 가치가 있습니다.

![Image](/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_1.png)

5. **구조화된 데이터의 낙원**: 클래식 검색은 제품 카달로그, 분류 체계, 메타 데이터 풍부한 데이터베이스와 같이 잘 구조화된 데이터에서 번성합니다. 정확한 키워드는 이러한 조직화된 시스템을 레이저 포커스로 탐색하여 특정 정보를 효율적으로 검색할 수 있습니다.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

6. 친숙한 친구: 전통적인 검색 방법에 익숙한 사용자들에게는 클래식한 접근 방식이 편안한 인터페이스를 제공합니다. 그들은 게임의 규칙을 이해하므로 학습 곡선 없이 필요한 것을 쉽게 찾을 수 있습니다.

7. 비용 효율적인 옵션: 클래식한 검색 인프라를 구현하고 유지하는 데는 의미론적 대응물에 비해 더 적은 계산 성능과 자원이 필요합니다. 이는 작은 조직이나 복잡하지 않은 검색 요구 사항을 가진 애플리케이션에게 예산 친화적인 솔루션이 됩니다.

# 컨셉 증명 — 나의 기사들을 키워드 검색하기

그래서 나는 직접 테스트해 보기로 결정했습니다!

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

100개의 미디엄 기사를 텍스트 파일로 저장하고 데이터베이스를 구축하기 시작했어요. 목표는(참 간단해 보일 수 있지만...) 내 기사들의 모든 키워드를 안내해주는 검색 창을 갖는 것이에요.

![이미지](/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_2.png)

# 어려움

먼저 필요한 db의 종류를 결정해야 했어요. 이건 간단한 검색이니까 전통적인 데이터베이스가 적당할 거 같아요. 저는 pandas 데이터프레임을 선택했어요.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

두 번째로 고려해야 할 사항은 데이터베이스 내의 관계입니다: 키워드를 검색하고 쿼리와 일치하는 텍스트 청크를 반환하고 싶습니다. 그러나 동일한 키워드가 매우 동일한 청크를 반환하면 해당 청크 중 하나만 원합니다. 이해를 돕기 위해 설명드리겠습니다:

저의 기사 'Hugging Face로 LLM을 통한 히치하이커 안내서'에는 많은 청크가 있고, 각각에는 3개 또는 4개의 키워드(예: hitchhiker, llm, guide, ai)가 있습니다.

![이미지](/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_3.png)

첫 두 hits에서 청크가 동일하지만 다른 키워드를 가리키는 것을 볼 수 있습니다. 실제로 쿼리에서 요청한 것과 일치합니다. 동일한 적용은 세 번째와 네 번째 태그(키워드)에도 적용되며 동일한 문서 청크가 반환됩니다.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

우리는 결과를 유일하게 유지하고 싶어해요 (이미 언급된 청크가 있으면 그 중 하나만 남겨둡니다).

# 데이터 준비 방법

데이터 수집 및 처리가 이 작업의 주요 관점입니다. 좋은 점은 우리가 풍부해질 때 필요한 단계를 사용하여 RAG 전략도 향상할 수 있다는 것입니다.

데이터 수집 중 (우리의 기사들) 우리는 사용자 지정 청크로 나누고, LangChain 문서 형식으로 저장하기 전에 그 특정 청크의 키워드를 추출하기 위해 KeyBERT (이 매우 빠릅니다)를 실행합니다.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

그런 다음 키워드도 메타데이터로 추가합니다.

다음 단계는 데이터베이스를 생성하는 것입니다: 관계형 데이터베이스가 아니기 때문에, 각 청크마다 키워드 하나 당 레코드를 갖기를 원합니다.

허들 섹션으로 돌아가 볼까요: 같은 예제를 사용하면, 기사 "A Hitchhiker Guide to LLM with Hugging Face"의 첫 번째 청크에는 4개의 키워드가 있습니다 (예: hitchhiker, llm, guide, ai). 데이터베이스에는 이 청크에 대해 4개의 항목이 있어야 합니다. 즉, 하나는 hitchhiker, 하나는 llm, 하나는 guide, 그리고 마지막으로 ai에 대한 항목이 있어야 합니다.

데이터베이스가 엄청나게 커질 거에요!!! 하지만 누가 신경을 쓰겠어요? Pandas는 정말 효율적이고 간단한 키워드 일치를 실행할 것이기 때문에 복잡하지 않아요!

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

# 그래픽 인터페이스

정말 간단해야 해요.

검색을 간소화하기 위해 Streamlit에서 multiselect 라는 특별한 위젯을 사용할 거에요. 이 위젯은 가능한 선택 사항 목록을 전달할 수 있는 화제적인 대화형 입력 위젯으로, 여러 개를 선택할 수 있고, 또한 타이핑을 시작하면 기존 목록에서 일치하는 항목이 나타나요.

그래서 중요한 작업 중 하나는 db에서 모든 키워드 태그를 추출하고, 중복을 제거하는 거에요.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

```js
st.session_state.kwcollection = st.session_state.df["tag"].unique();
```

다중 선택 객체는 파이썬 리스트를 반환합니다. 이것은 매우 좋은데, pandas 데이터프레임을 .isin() 메서드로 필터링할 수 있기 때문입니다.

```js
dfsearch1 = st.session_state.df[st.session_state.df["tag"].isin(kw)];
```

여기서 kw는 다중 선택 객체에서 얻은 파이썬 리스트이며, st.session_state.df는 세션 상태 객체에 저장된 데이터프레임입니다. 이렇게 함으로써 전역 변수로 사용되며 Streamlit이 재 실행될 때마다 변경되지 않습니다.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

# 결론

만약 백그라운드에서 사용된 코드를 보고 싶다면 알려주세요. 직접 시도해보는 것이 가장 좋을 거예요. 판다스 작업을 다시 해보는 것은 항상 좋은 기회가 되거든.

의견을 남겨주시고, 필요하다면 후속 내용을 작성할게요 😉

이 검색 전략이 얼마나 빠른지 볼 수는 있지만... 기억하세요, 고전적인 키워드 검색이 항상 만병통치약은 아니라는 걸요.

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

세세한 질문이나 다양한 관점을 탐구하려면, 의미론적 검색은 명백한 장점을 제공합니다.

그러나 정밀도, 속도, 통제 및 익숙함이 중요할 때는, 특히 잘 구조화된 데이터와 함께 사용될 때, 이 검증된 방법은 올바른 사람의 손에 강력한 도구로 남아 있습니다.

이 기사를 즐겨보셨으면 좋겠습니다. 만약 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다:

- 이 이야기에 대해 많이 클랩하기
- 기억하기에 더 적합한 부분을 강조하기 (나중에 찾기 쉽고, 나는 더 나은 기사를 쓸 수 있습니다)
- 자체 인공지능 구축 방법을 배우려면 이 무료 eBook 다운로드하기
- 나의 링크를 사용하여 미디엄 멤버십 가입하기 (매월 $5로 무제한 미디엄 이야기 읽기)
- 미디엄에서 나를 팔로우하기
- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi

<!-- seedividend - 사각형 -->

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4877378276818686"
     data-ad-slot="1898504329"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>

<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

더 많은 정보를 원하시면 아래의 아이디어를 확인해보세요:

## Medium의 Boost / AI 라이프 해킹 / 무료 GPT 대안 / AI 아트
