---
title: "Nodejs 어플리케이션의 성능 최적화 기술"
description: ""
coverImage: "/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png"
date: 2024-05-14 12:37
ogImage: 
  url: /assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png
tag: Tech
originalTitle: "Performance Optimization Techniques for Node.js Applications"
link: "https://medium.com/@abubalogun/performance-optimization-techniques-for-node-js-applications-4cb009430634"
---


<img src="/assets/img/2024-05-14-PerformanceOptimizationTechniquesforNodejsApplications_0.png" />

웹 애플리케이션을 구축할 때 성능이 중요합니다. 빠르고 신뢰할 수 있는 애플리케이션을 구축하여 사용자 경험을 향상시키는 것이 목표입니다. 반응이 빠른 앱은 사용자를 끌어들이고 보유율을 향상시킵니다. 그에 반해, 느린 애플리케이션은 사용자를 좌절시키고 포기로 이끌 수 있습니다.

특히 Node.js로 백엔드 서비스를 구축하는 경우, 성능은 후술할 수 없습니다. Node.js는 빠른 속도로 알려져 있지만, 이것이 반드시 애플리케이션이 최적으로 작동할 것이라는 것을 보장하지는 않습니다. Node.js의 잠재력을 극대화하려면 의도적인 조치를 취해야 합니다.

이 기사에서는 Node.js 애플리케이션의 성능을 개선하기 위한 다양한 기술과 모범 사례를 살펴보겠습니다.



# 성능 최적화의 중요성

성능 최적화는 언제나 애플리케이션의 속도를 향상시키는 것만을 의미하는 것은 아닙니다. 또한 메모리, CPU, 대역폭과 같은 자원을 낭비하지 않는 것에 관한 것입니다. 최적화되지 않은 앱은 자원을 낭비하고 더 많은 비용이 들어갑니다. 하드웨어 자원이 제한적인 상황에서 최적화를 통해 현재의 자원을 최대한 활용할 수 있습니다. 불필요한 업그레이드를 하지 않고 예산 이상으로 지출하는 일을 피할 수 있습니다.

확장성 또한 중요합니다. 적절히 최적화된 앱은 문제 없이 동시 사용자들을 처리할 수 있습니다.

Node.js의 논블로킹 스타일 때문에 최적화가 더욱 중요합니다. Node는 병렬 IO에 좋지만 CPU 집약적인 작업이 전체적으로 성능을 늦추는 일이 발생할 수 있습니다. 이벤트 루프가 원활하게 작동하도록 유지해야 합니다. 최적화되지 않은 코드는 성능 저하로 이어지며, 이는 불만족스러운 사용자, 높은 비용, 그리고 놓치는 기회로 이어질 수 있습니다. 적절한 최적화는 이러한 문제를 방지하고 애플리케이션이 효율적이고 수익성 있게 운영될 수 있도록 유지해줍니다.



# 성능 최적화를 고려해야 하는 시점은 언제일까요?

Node.js 앱을 구축할 때 항상 성능 최적화를 고려해야 합니다. 초기 계획부터 배포 이후까지 항상 염두에 둬야 합니다. 그럼에도 불구하고 성능 최적화에 실제로 노력을 기울여야 하는 특정 시점들이 있습니다:

- 초기 개발: 디자인, 아키텍처, 알고리즘 및 접근 방식을 처음부터 올바르게 정하는 것은 나중에 큰 이익을 가져다 줍니다. 효율성, 확장성 및 유지보수성을 초기에 우선시하는 것이 성공의 열쇠가 됩니다.
- 기술적 부채 해결: 앱이 성장하고 발전함에 따라 기술적 부채가 늘어납니다. 이를 방치하면 시간이 지남에 따라 성능을 제한할 수 있습니다. 정기적인 리팩터링, 최적화 작업 및 코드 정리를 통해 볼륨을 줄이는 것이 중요합니다.
- 새로운 기능: 새로운 기능을 추가하는 것은 성능에 반드시 영향을 미칩니다. 새로운 기능을 출시하기 전에 전반적인 사용자 경험을 감소시키지 않도록 작업해야 합니다.
- 배포 전: 배포하기 전에 실제로 앱이 실제 워크로드를 처리할 수 있는지 확인해야 합니다! 배포 전에 철저한 성능 테스트와 튜닝은 필수입니다.
- 병목현상 대응: 개발, 테스트 또는 프로덕션 중에 느려짐이나 문제가 발생할 때마다 성능 병목 현상을 신속히 식별하고 최적화를 통해 해결해야 합니다.
- 운영 비용 절감: 최적화가 잘 된 앱은 CPU, 메모리, 대역폭 및 기타 부분에 더 관대하여 실행 및 확장 비용이 적게 들게 됩니다. 비용을 고려하는 팀에게 큰 이점이 됩니다.
- 부하 테스트: 모의 트래픽을 사용하여 부하 테스트를 진행하면 스케일링 제한, 과도한 부하를 견뎌야 하는 병목 현상 및 출시 전 최적화 기회를 발견할 수 있습니다.
- 인프라 확장: 수요를 충족하기 위해 인프라가 성장함에 따라 최적화 전략도 가져가야 합니다. 확장을 위한 튜닝을 재방문하여 효율성을 확보해야 합니다.
- 제한된 환경 자원: 엣지 장치, 임베디드 시스템 또는 다른 제한된 사용 사례의 경우, 제한된 자원을 극대화하기 위해 가혹한 최적화가 필요합니다.
- 지속적인 유지보수: 최적화는 일회성 작업이 아닙니다. 데이터가 증가하고 사용 패턴이 변하며 새 코드가 시간이 지남에 따라 도입될 때 계속해서 검토하고 조정해야 합니다.
- 프로덕션 모니터링: 마지막으로, 프로덕션 환경에서 항상 귀를 기울이세요! 사용자 불만이나 느려짐을 나타내는 메트릭이 있으면 즉시 조사하고 개선 작업을 시작해야 합니다.

# Node.js 앱 최적화 기술



지금 당신이 Node.js 앱의 성능 최적화를 우선시해야 하는 시기를 이해했군요. 이제 Node.js 애플리케이션에서 최대 성능을 뽑아내는 가장 효과적인 방법을 알아봅시다:

# 코드 프로파일링

Node.js 애플리케이션을 최적화하려면 먼저 어디서 성능 병목 현상을 일으킬 수 있는지 알아야 합니다. 프로파일링을 통해 이를 파악할 수 있습니다. 이를 통해 코드 중 어느 부분이 가장 많은 시간과 자원을 소비하고 있는지를 보여줍니다. 느린 부분을 알면 그 부분을 개선하는 데 집중할 수 있습니다. 현재 앱의 상태를 결정하기 위해 다음 테스트를 수행해야 할 수도 있습니다:

부하 테스트: 이는 앱이 정상적이고 예상대로의 사용자량과 트래픽을 처리하는 방식을 확인합니다. 앱을 정기적으로 사용할 때 발생하는 느림 현상이나 문제점을 발견할 수 있습니다.



스파이크 테스팅: 이는 앱에 갑작스럽게 많은 사용자나 활동을 던집니다. 일반 부하보다 많습니다. 수요가 예상치 못하게 증가했을 때 앱이 어떻게 반응하는지, 어떤 한계에 도달하는지 보여줍니다.

스트레스 테스팅: 이 테스트는 부하를 점진적으로 늘려서 앱을 한계까지 밀어붙입니다. 앱이 고장 나기까지 처리할 수 있는 최대치를 보여줘, 앱의 약점이나 부족한 리소스를 식별할 수 있게 해 줍니다.

확장성 테스팅: 이는 앱이 추가적인 리소스(서버 또는 메모리)를 추가함으로써 더 많은 사용자와 트래픽을 쉽게 처리할 수 있는지를 살펴 봅니다. 앱의 확장을 원할하게 막는 병목 현상이나 구조적 문제를 확인합니다.

이 상기 중 일부 또는 전부의 테스트를 수행하는 것은 여러 중요한 측정 항목을 제공합니다.



- 응답 시간
- 평균 지연 시간
- 오류율
- 초당 요청 수
- 처리량
- CPU 및 메모리 사용량
- 동시 접속 사용자

그리고 더 많은 정보.

# 네이티브 클러스터 모듈 또는 PM2를 사용하여 확장하기

Node.js에는 멀티코어 시스템을 활용하고 부하를 여러 워커 프로세스로 분산시킬 수 있는 내장 클러스터 모듈이 함께 제공됩니다. 이를 통해 사용 가능한 모든 CPU 코어를 활용하여 응용 프로그램의 성능과 확장성을 향상시킬 수 있습니다. 여러 워커 프로세스 간에 부하를 분산시키는 방법을 살펴봅시다:



```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`마스터 프로세스 ${process.pid}가 실행 중입니다`);
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  cluster.on('exit', (worker, code, signal) => {
    console.log(`워커 ${worker.process.pid}가 코드 ${code}와 시그널 ${signal}로 종료되었습니다`);
    console.log('새로운 워커를 시작 중');
    cluster.fork();
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('워커 프로세스에서 안녕하세요\\n');
  }).listen(8000);
  console.log(`워커 ${process.pid}가 시작되었습니다`);
}
```

마스터 프로세스는 각 사용 가능한 CPU 코어에 대해 새로운 워커 프로세스를 포크합니다. 각 워커 프로세스는 포트 8000에서 수신하는 HTTP 요청을 처리합니다. 워커 프로세스가 충돌하면 마스터 프로세스가 알림을 받고 충돌한 프로세스를 대체하기 위해 새로운 워커를 생성합니다.

대부분의 경우, 추가 기능을 제공하며 편의성을 제공하는 PM2 (Process Manager 2)를 사용하는 것이 좋습니다. 보일러플레이트를 작성할 필요가 없습니다.

PM2를 사용하여 확장하기 위해서는 먼저 설치해야 합니다:




```js
npm install pm2 --save-dev
```

설치가 완료되면 PM2를 사용하여 애플리케이션을 시작하고 클러스터링을 활성화할 수 있습니다:

```js
pm2 start app.js -i max
```

-i max 플래그는 PM2가 사용 가능한 CPU 코어 수만큼 애플리케이션 인스턴스를 시작하도록 지시합니다. PM2는 자동으로 이러한 인스턴스 간에 들어오는 요청을 로드 밸런싱합니다.



다음과 같이 수동으로 시작할 인스턴스 수를 지정할 수도 있습니다:

```js
pm2 start app.js -i 4
```

당신의 어플리케이션의 인스턴스를 네 개 시작할 것입니다.

PM2는 제로 다운타임 리로드, 모니터링, 로깅과 같은 부가 기능을 갖추고 있어서 프로덕션 환경에서 Node.js 어플리케이션을 관리하고 확장하는 인기 있는 도구입니다.



# Gzip 압축 활용하기

Gzip 압축은 서버와 클라이언트 간에 전송되는 데이터 양을 현저히 줄여 더 빠른 응답 시간과 향상된 성능을 제공할 수 있습니다. 특히 HTML, CSS, JavaScript와 같은 대량의 텍스트 기반 콘텐츠를 제공하는 애플리케이션에 대해 유용합니다.

Node.js에서는 compression이라는 라이브러리를 사용하여 Gzip 압축을 활성화할 수 있습니다. compression을 사용하려면 먼저 npm을 통해 설치하고 express 프로젝트에 가져와야 합니다:

compression 라이브러리 설치하기:



```js
npm install compression
```

압축 라이브러리를 사용하는 방법:

```js
const express = require('express');
const compression = require('compression');
const app = express();

// Gzip 압축 활성화
app.use(compression());

app.use(express.static('public'));

app.listen(3000, () => {
  console.log('서버가 http://localhost:3000 에서 실행 중입니다');
});
```

이 미들웨어는 요청의 Accept-Encoding 헤더와 응답의 콘텐츠 유형에 따라 응답 데이터를 자동으로 압축합니다.



텍스트 기반 콘텐츠를 제공할 때 Gzip을 사용하면 서버와 클라이언트 간 전송되는 데이터 양을 줄일 수 있어 더 빠른 응답 시간을 얻을 수 있어요.

# 타임아웃 블로킹 I/O 작업 사용하기

Node.js는 많은 연결을 동시에 처리할 수 있도록 설계되어 있어서 묶이는 작업을 피해야 합니다. 그러나 파일을 읽는 등 느린 I/O 작업이 막히게 되면 Node.js가 효율적으로 다른 작업을 수행하는 것을 막을 수 있어요. 이를 방지하기 위해 느린 I/O 작업에는 타임아웃을 사용하세요. 타임아웃은 작업이 완료되는 데 걸리는 최대 시간을 설정해줘요. 너무 오랜 시간이 걸리면 작업을 취소하거나 다른 모든 것을 막지 않고 처리할 수 있어요.

파일을 읽을 때 타임아웃을 설정하는 것은 매우 간단해요:



```js
const fs = require('fs');


const MAX_TIMEOUT = 5000;
const readFile = (filePath, callback) => {
  fs.readFile(filePath, (err, data) => {
    if (err) {
      return callback(err);
    }
    callback(null, data);
  });
};

const readFileWithTimeout = (filePath, callback) => {
  const timeoutId = setTimeout(() => {
    callback(new Error('파일 읽기 작업 시간 초과'));
  }, MAX_TIMEOUT);
  readFile(filePath, (err, data) => {
    clearTimeout(timeoutId);
    if (err) {
      return callback(err);
    }
    callback(null, data);
  });
};
```

readFileWithTimeout 함수는 setTimeout을 사용하여 5초 타임아웃을 설정합니다. fs.readFile 작업에 더 오랜 시간이 걸리면 타임아웃 콜백이 트리거되어 제공된 콜백에 오류를 전달합니다.

만약 타임아웃 전에 readFile이 완료되면 clearTimeout이 타임아웃을 취소하고 파일 데이터를 콜백에 전달합니다.

타임아웃 값은 앱의 요구 사항을 균형있게 유지해야 합니다. 너무 짧으면 합법적인 긴 작업을 자르는 위험이 있고, 너무 길면 타임아웃을 사용하는 목적을 상쇄시킬 수 있습니다.




# I/O 작업에는 스트리밍을 사용하세요

스트리밍은 대용량 파일, 네트워크 응답 또는 데이터가 전체가 메모리로 로드되기를 기다리는 대신 도착하는 즉시 처리해야 하는 시나리오와 같이 데이터를 처리해야 하는 경우에 매우 유용합니다. 특히 대량의 데이터를 다루는 I/O 작업을 최적화할 때 Node.js 애플리케이션에 대한 강력한 기술 중 하나입니다.

만약 수백만 개의 행이 있는 멀티 기가바이트 CSV 파일을 읽어야 한다고 가정해 봅시다. 스트림을 사용하여 데이터를 작은 조각 단위로 처리할 수 있습니다. 어떤 말인지 확인해 볼까요:

```js
const fs = require('fs');
const stream = require('stream');
const csvParser = require('csv-parser');

const csvStream = fs.createReadStream('bigdata.csv')
  .pipe(csvParser());

const writableStream = new stream.Writable({
  write(chunk, encoding, next) {
    console.log('CSV 데이터 청크를 받았습니다:', chunk);
    next();
  }
});

csvStream.pipe(writableStream);

writableStream.on('error', (err) => {
  console.error('에러 발생:', err);
});

writableStream.on('finish', () => {
  console.log('CSV 데이터 처리 완료.');
});
```



가독성 있는 csvStream은 CSV 데이터를 작성 가능한 스트림으로 물 흐르듯이 전달합니다. write 메서드는 전체 CSV 파일이 메모리에 로드되기를 기다리지 않고 각 청크가 도착할 때마다 처리합니다.

스트리밍은 메모리 블로트를 방지하고 대용량 CSV 파일과 같은 I/O 집중적 작업의 성능을 향상시킵니다. 메모리에 완전히 로드하는 것이 현실적이지 않거나 대용량 API 응답인 대규모 데이터 집합을 처리해야 하는 모든 시나리오에 이상적입니다.

# 종속성 최소화

의존성은 유용한 기능을 제공하고 작업 흐름을 가속화할 수 있지만, 너무 많은 종속성을 갖거나 오래된 또는 불필요한 종속성을 사용하는 것은 때로 응용 프로그램의 성능에 부정적으로 영향을 미칠 수 있습니다.



자바스크립트 애플리케이션에서 종속성을 최소화하는 방법을 살펴봐요:

- 검토하고 사용하지 않는 종속성 제거: 프로젝트의 종속성을 주기적으로 검토하고 사용되지 않거나 불필요한 패키지를 제거해요. npm-prune이나 depcheck과 같은 도구를 사용하여 사용되지 않는 종속성을 식별하고 제거할 수 있어요.

```js
npm install -g npm-prune
```

prune 명령어를 실행하여 사용되지 않는 종속성을 제거하세요.



```js
npm prune
```

- 정기적으로 의존성 업그레이드: 최신 안정 버전으로 정기적으로 업그레이드하여 의존성을 최신 상태로 유지하세요. 오래된 의존성은 보안 위험을 가져올 수 있고 버그를 발생시킬 수 있으며 성능 향상을 놓칠 수 있습니다. npm-check-updates나 npm outdated와 같은 도구를 사용하여 사용 가능한 업데이트를 확인할 수 있습니다.

패키지 설치

```js
npm install -g npm-check-updates
```



업데이트 가능한 내용을 확인해보세요:

```bash
npm-check-updates
```

의존성 패키지를 업데이트하세요:

```bash
npm-check-updates -u
npm install
```



- 번들러와 트리 쉐이킹 활용: Webpack이나 Rollup과 같은 모듈 번들러를 사용하여 트리 쉐이킹을 수행할 수 있습니다. 이는 응용 프로그램과 의존성에서 사용되지 않는 코드를 제거하는 프로세스로, 최종 번들 크기를 크게 줄이고 성능을 향상시킬 수 있습니다.
- 작은 및 특정한 종속성 선호: 종속성을 선택할 때, 필요한 기능만 제공하는 작고 집중된 패키지를 선택하는 것이 좋습니다. 사용하지 않는 기능이 많은 대규모의 모놀리틱 라이브러리보다 낫습니다.
- 사용자 정의 코드 작성 고려: 경우에 따라, 필요한 기능이 상대적으로 간단하거나 응용 프로그램에 특정한 경우에는 의존성에 의존하는 대신 사용자 정의 코드를 작성하는데 가치가 있을 수 있습니다.

# 부하 분산

Node.js 응용 프로그램이 성장하고 더 많은 트래픽을 처리할 때, 성능과 가용성을 유지하기 위해 해당 부하를 여러 서버에 분산해야 합니다. 여기서 부하 분산이 유용하게 사용됩니다. 부하 분산은 들어오는 요청을 여러 서버 그룹에 분산하여 어떤 서버가 과부하가 걸리지 않도록 합니다. 다음과 같은 소프트웨어 솔루션을 사용할 수 있습니다:

- Nginx 또는 HAProxy
- 클라우드 부하 분산 서비스 (AWS ELB, Google Cloud Load Balancing 등)



효과적인 로드 밸런싱은 작업 부하를 공유하여 성능을 향상시킵니다. 또한 장애 허용성을 강화합니다. 한 대의 서버가 실패하면 트래픽이 건강한 서버로 리디렉션되어 가용성을 유지합니다.

Node.js는 백엔드 서비스를 구축하는 데 훌륭한 도구입니다. 그러나 정적 파일을 제공하는 데 최적화되어 있지 않아 이 작업을 수행할 때 성능 병목 현상을 겪을 수 있습니다. Nginx를 사용하여 Node.js 응용 프로그램의 정적 자산을 제공하는 반대 프록시로 사용할 수 있습니다. 이렇게하면 Node.js 앱이 동적 요청과 응용 프로그램 논리를 처리하고 있는 동안 Nginx가 정적 파일 제공 능력을 최적화하여 성능과 확장성을 향상시킵니다.

# CPU 집약적 작업 외부로 이전하기



Node는 한 번에 여러 I/O 작업을 처리하는 데 능숙합니다. 그러나 숫자 처리나 미디어 처리와 같은 무거운 CPU 작업에 대해선 싱글 스레드로 구성되어 있어 성능이 떨어질 수 있습니다. 이 CPU 집약적인 작업은 모든 것을 늦추고 지연을 초래할 수 있습니다.

해결책은 CPU 집약적인 작업을 별도의 프로세스나 서비스로 오프로드하는 것입니다. 이렇게 하면 주요 Node 프로세스가 일반 I/O 작업을 위해 재빠르게 유지됩니다.

다음과 같은 것들을 사용할 수 있습니다:

- 여러 코어에 병렬로 CPU 작업을 실행하기 위한 자식 프로세스
- Node 내에서 별도의 스레드에서 CPU 작업을 실행하기 위한 워커 스레드
- 클라이언트 측 CPU 스크립팅을 위해 백그라운드 스레드에서 사용되는 웹 워커
- 코드를 클라우드에서 실행하기 위한 AWS Lambda와 같은 서버리스 함수
- 이미지 처리와 같은 CPU 집약적인 작업을 위해 설계된 외부 API



숫자를 계산하는 부분을 분리함으로써 Node의 단일 스레드를 너무 많이 사용하지 않도록 할 수 있어요. 앱은 기존에 좋은 성능을 보여주던 정상적인 네트워킹 및 I/O 작업에 반응하면서 원활하게 작동할 거에요. CPU도 다른 부분에서 충분히 활용할 수 있게 되죠.

# 최신 Node.js 버전 사용하기

Node.js는 적극적으로 개발 및 유지보수되는 프로젝트로, 새로운 기능, 성능 향상 및 버그 수정이 소개되는 빈도 높은 릴리스들을 발표하고 있어요. 구 버전의 Node.js를 사용하면 성능 문제, 보안 취약점 및 최신 라이브러리 및 프레임워크와의 호환성 문제가 발생할 수 있어요. 새로운 Node.js 릴리스는 V8 JavaScript 엔진에 대한 최적화와 개선 사항이 포함되어 있어 실행 시간 및 전체 성능을 향상시킬 수 있어요.

Node.js를 업그레이드하려면 Node.js 공식 웹사이트에서 최신 버전을 다운로드하거나 nvm과 같은 버전 관리자를 사용할 수 있어요. 이 도구를 사용하면 다양한 Node.js 버전을 쉽게 설치하고 전환할 수 있어요.



만약 이미 컴퓨터에 nvm이 설치되어 있다면, 최신 Node.js 버전을 쉽게 설치할 수 있어요.

아래 명령어를 실행하여 사용 가능한 Node.js 버전을 확인할 수 있어요:

```js
nvm ls-remote
```

최신 Node.js 버전을 설치하세요:



```js
nvm install <nodejs 버전>
```

가장 최근에 설치된 버전을 사용하려면:

```js
nvm use <nodejs 버전>
```

호환성 문제로 인해 다른 Node.js 버전 간을 전환하려면 동일한 nvm use 명령을 사용할 수 있습니다. 즉, Node.js 버전을 최신 상태로 유지하여 응용 프로그램이 최신 성능 향상을 누리는 것이 좋습니다.



## 마무리

성능 최적화는 Node.js 애플리케이션의 전체 개발 수명 주기 동안 내재화되어야 하는 지속적인 반복 프로세스입니다. 구현할 최적화 기술을 선택하기 전에 각 전략을 귀하의 특정 응용 프로그램 요구 사항, 인프라 및 성능 목표에 대해 평가해보세요.

해피 해킹!