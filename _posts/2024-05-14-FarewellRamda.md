---
title: "작별인사, Ramda"
description: ""
coverImage: "/assets/img/2024-05-14-FarewellRamda_0.png"
date: 2024-05-14 15:28
ogImage: 
  url: /assets/img/2024-05-14-FarewellRamda_0.png
tag: Tech
originalTitle: "Farewell, Ramda"
link: "https://medium.com/better-programming/farewell-ramda-8f4d85bf64e0"
---


## 옛날 코드를 해독하느라 수고스러운 적이 있으신가요? 종종 Ramda가 관련되어 복잡한 작업을 하게 만들어 다른 간단한 대안을 찾게 했었죠.

![Ramda 이미지](/assets/img/2024-05-14-FarewellRamda_0.png)

# 소개

두 해 전의 코드를 만나서 변경을 하려고 애를 쓰시는 일이 있었나요? 수정할 곳을 찾기 위해 많은 시간을 들이지만 어디서 어떻게 변경을 해야 할지 알 수 없는 경우가 많아요. 가끔 그럴 때마다, 아주 놀라운 일인데 고대 문명의 암호화된 메세지를 해독하려는 느낌과도 같은 것이었어요. 저는 이런 경험을 여러 차례 해왔는데, 대부분 Ramda가 관련되어 있었습니다. 이 경험이 중복됨을 느끼며, 대안을 탐구하고 제 코드 유지보수 전략을 재고하게 되었죠.



# 새로운 Ramda의 탐험

Ramda는 함수형 프로그래밍 원칙을 받아들이고 견고한 유틸리티 함수 세트를 제공하여 여러분을 강력하게 지원하는 환상적인 JavaScript 라이브러리입니다. 이 라이브러리는 불변 데이터를 다루고 함수를 조합하며 코드에 선언적인 풍미를 불어넣는 데 주력합니다. Ramda를 사용하면 자동으로 커링이 될 뿐만 아니라 함수를 부드럽게 조합하고 불변 데이터를 간편하게 다룰 수 있습니다. 또한, 함수의 인수를 명시적으로 언급하지 않고 정의하는 포인트프리 스타일의 우아함을 받아드리도록 격려합니다. Ramda는 JavaScript 프로젝트에서 함수형 프로그래밍을 더 접근하기 쉽고 표현력있고 즐거운 경험으로 만들어냅니다.

Ramda를 사용하기 시작했을 때, "와우" 효과를 경험했습니다. 선언적인 코드가 얼마나 우아해졌는지를 즐겼고, 툴킷의 유용한 함수들 덕분에 복잡한 논리를 한 문장으로 표현할 수 있었습니다. Ramda로 과제를 해결할 때마다 뇌에서 보상 느낌을 받았습니다. 더 많은 논리를 통합할 수 있었을 때 더 큰 만족감을 느꼈습니다. 또한 이 같은 감정 이외에도 Ramda는 데이터 불변성 유지, 선언적 표현을 강화하고 편리한 도우미 함수 세트를 통해 루틴 작업을 해결하는 등 여러 가지 방법으로 코드를 획기적으로 개선시켰습니다.

# Ramda의 쇠퇴와 JavaScript의 부흥



그러나 JavaScript가 진화함에 따라 저와 많은 동료들은 Ramda, Lodash 등의 라이브러리를 대체하여 언어의 기본 도구와 기능을 점차적으로 더 많이 활용하게 되었습니다.

어떤가요? 언어의 기본 기능만을 사용하여 간단하고 깔끔한 코드를 작성하는 그 기분이 참 달콤하지 않나요? 제가 생각하기에 우리 모두가 한 번쯤은 느꼈을 거에요. 개발자로서 우리는 무엇을 가장 잘 알고 있는지에 자주 익숙해지는 경향이 있습니다. 그래서 이 경우에는 구식이지만 좋은 기존의 네이티브 JavaScript에 더 많이 기댈 때가 많아요.

마치 꾸준하고 깔끔한 컵 커피를 즐기는 것처럼, 네이티브 JavaScript로 작업하는 것에는 특별한 즐거움이 있습니다. 이것은 우리에게 새로운 라이브러리의 세세한 사항을 배우지 않고도 즉시 시작할 수 있는 익숙함과 직관성을 제공해줍니다.

ES5 시절부터 ES2015, ES2017를 거쳐 새롭고 화려한 ES2020까지 자바스크립트는 크게 성장했습니다. 각 업데이트는 새로운 멋진 기능을 가져와 우리의 코딩 생활을 훨씬 더 간단하게 만들어주었으며, 자바스크립트 코드의 기능 및 선언적 성격을 크게 향상시켰습니다.



먼저 배열을 다루는 map(), reduce(), filter()와 같은 고차 함수부터 시작해보죠. 이제 이들은 쉬울 정도로 쉽게 느껴졌어요. 만만한 일이었죠.

다음으로 멋진 화살표 함수가 등장했어요. 이런 신규 추가 기능들은 간결하고 직관적이었어요. 코드를 읽고 이해하기 쉽게 만들어 주었죠.

이어서 템플릿 리터럴이 등장했는데, 이것들은 문자열 다루기를 바꿔 놓았어요. 더 이상 복잡한 연결 작업은 사라지고, 부드럽고 신뢰할 수 있는 문자열 생성만 남았죠.

펼침 구문은 또 다른 유용한 추가였어요. 배열이나 객체를 확장하거나 변경 불가능성을 유지하는 것이 쉬워졌죠. 마지막으로 파괴 할당, 옵셔널 체이닝, 널 병합 연산자라는 유용한 세 가지를 갖게 되었어요. 이들은 코드를 더 쉽고 눈에 잘 들어오도록 만들어 주었어요.



네이티브 JavaScript 기능을 사용하면 익숙함과 간편함을 느낄 수 있어요. 이런 친숙함 덕분에 개발자들은 학습 과정 없이도 생성할 수 있어요. 우리 많은 이들은 이 언어의 핵심에 매료되어 있어요. JavaScript의 핵심이자 경량화되고 유연한 네이티브 기능들은 JavaScript의 핵심이자 최적화가 고려된 성능 또한 가지고 있어요.

예를 들어, 람다(Ramda)와 같은 라이브러리는 코드를 추가적인 추상적인 단계로 둘러싸지만, 네이티브 JavaScript는 빠른 속도로 실행됩니다.

JavaScript 엔진인 V8과 같은 엔진의 최적화로 이러한 기능들은 더욱 발전합니다. V8의 개발자들은 지속적으로 네이티브 기능들에 최적화를 진행하고 있어요. 이는 JavaScript 코드가 원활하고 빠르게 실행되도록 보장해줍니다. JavaScript 코드가 웰오일 된 기계처럼 돌아가게 해줘요.

하지만 속도만이 중요한 것은 아니에요. 통합성과 호환성도 중요해요. 이러한 네이티브 기능은 다른 언어의 부분들과 원활하게 연계되어 작동하며, 다양한 API와 JavaScript의 광범위한 생태계와 조화롭게 작동해요.



네이티브 JavaScript의 또 하나의 장점은 다양한 ECMAScript 버전과의 호환성 및 최소한의 종속성을 가지고 있다는 것입니다. 지속적인 ECMAScript 업데이트로 계속해서 발전하는 이 언어는 많은 개발자들에게 최고의 선택지입니다. 원래 것이 이렇게 잘되는데 새로운 것을 찾아야 할 이유가 무엇인가요?

# "람다마이즈드" TypeScript에 머리를 쥐어박다

프로젝트를 TypeScript로 전환하고 기존의 람다 코드를 통합하려고 할 때 새로운 문제가 발생할 수 있습니다. TypeScript는 정적 타입을 제공하여 코드 안전성을 향상시키고 개발자 생산성을 증가시키는 장점을 제공합니다. 그러나 TypeScript에 람다를 섞을 때는 타이핑 접근 방식과 호환성의 차이로 인해 약간 까다로워질 수 있습니다.

람다 함수에서 사용하는 타입이 TypeScript typings와 일치하는지 확인하는 것이 주요한 고민거리입니다. 람다는 일부 TypeScript typings을 제공하지만 모든 시나리오를 다루지 못하거나 최신 람다 버전과 호환되지 않을 수 있습니다. 이로 인해 기대하는 타입과 추론된 타입 간의 불일치가 발생할 수 있어 소매를 걷어 올리고 타입 주석을 수동으로 처리하거나 사용자 정의 typings를 생성해야 할 수도 있습니다.



또 다른 도전 과제는 Ramda의 함수형 프로그래밍 스타일인데, 함수 커링과 함수 조합이 있어 복잡할 수 있어요. TypeScript의 타입 추론은 이러한 각종 마무리를 따라가기에 어려울 수 있어요. 그래서 명시적인 타입 주석을 추가하거나 추가적인 어서션을 해야 모든 것이 제자리에 있도록 관리할 수 있어요. 이건 좀 복잡해지며 코드를 읽기 어렵고 유지보수하기 힘들 수 있어요.

더군다나, Ramda 코드가 TypeScript를 염두에 두지 않고 작성됐다면, 적절한 타입 주석과 문서가 부족할 수 있어요. 이는 TypeScript 규칙을 맞추고 타입 안전성을 보장하기 위해 코드 베이스를 리팩토링하고 적응시키기 위해 추가 시간과 노력을 투자해야 할 수 있다는 걸 의미해요.

한편, TypeScript와 함께 네이티브 JavaScript 기능을 사용하면 이러한 문제들을 해결할 수 있어요. TypeScript가 걱정 없이 타입을 정확하게 처리할 수 있어서 여러분의 삶을 훨씬 쉽게 만들 수 있어요. 원활한 통합과 향상된 TypeScript 지원은 네이티브 JavaScript 기능을 TypeScript 프로젝트에 매력적인 옵션으로 만들어 줘요, 특히 타입 안전성과 효과적인 개발을 목표로 할 때 더욱 그렇답니다.

# 말은 그만하고 코드를 보여줘



Ramda로 작성된 이 코드를 살펴보겠습니다. 이 코드는 매우 복잡한 논리를 수행하지는 않습니다. 상황 자체는 꽤 직관적입니다. 그러나 이에도 불구하고 이 스니펫의 논리를 이해하기 위해 내 두뇌는 노력해야 합니다.

```js
const result = R.pipe(
  R.filter(R.both(
    R.propSatisfies(R.gt(R.__, 25), 'age'),
    R.pathEq(['address', 'country'], 'USA')
  )),
  R.map(R.prop('name'))
)(users)

// 🤔 🤔 🤔
```

이 코드는 사용자의 나이와 거주 국가에 따라 사용자 목록을 필터링하며, 특히 미국에 거주하며 25세 이상인 사용자를 찾습니다. 위의 Ramda 예시는 R.pipe()를 사용하여 다중 작업을 연결해 함수형 프로그래밍 원리를 적용합니다. 논리가 제일 복잡한 것은 아니지만, 함수들의 계층적인 조합은 이해하기 위해 잠깐의 고민(또는 두 번의 고민)이 필요합니다.

이를 Lodash로 다시 작성하여 좀 더 나은 코드로 만들어볼 수 있습니다



```js
const resultL2 = _.map(
  _.filter(
    users,
    user => user.age > 25 && user.address.country === 'USA'
  ),
  'name'
)

// 👌👌👌
```

바로 Lodash 버전은 더 친근하다 느껴집니다. filter()와 map()을 사용해 콜백 함수 내에서 필터 조건을 직접적으로 표현하여 우리의 삶을 간단하게 만들어 줍니다. 그럼에도 불구하고 개선의 여지가 있다면, 더 간소화할 수 있는 방법은 여전히 남아 있습니다.

더 나아가서 이를 순수 JavaScript만 사용하여 다시 작성해 보겠습니다:

```js
const result = users
  .filter(
    user => user.age > 25 && user.address.country === 'USA'
  )
  .map(user => user.name)

// 🥹🥹🥹
```



아름다운!

구문은 간단하고 직관적이며 핵심 논리에서 우리 주의를 분산시키는 추상화 요소가 없습니다. 읽고 이해하기 쉬운 작업 목록이 표시됩니다. 동일한 필터링 및 매핑 작업을 수행하기 위해 filter() 및 map() 배열 메서드를 사용합니다. 필터링 조건은 콜백 함수 내부에 직접 작성되어 코드 스니펫을 더 읽기 쉽게 만듭니다. 실제로, 심지어 내 할머니도 이 코드를 읽어낼 수 있을 것 같아요.

전통적 코딩 스타일에 익숙한 사람들은 Ramda의 함수형 프로그래밍 및 커링 사용량이 많고 사용되는 이름 짓기 관행 때문에 코드를 이해하기 어려울 수 있습니다. 특히 프로젝트 내에서 다른 코드 스타일 사이를 전환해야 할 때는 더 어려울 수 있습니다. 본질적으로 특정 관행에 익숙하지 않은 경우 Ramda 코드를 읽는 것은 퍼즐을 푸는 것과 같을 수 있습니다. 이러한 낯설음으로 인해 여러 코딩 패러다임을 동시에 처리할 때 특히 읽고 따라가기 어려울 수 있습니다.

# 일부 변론의 말씀



잘못 이해하지 마세요. 이전에 제기한 우려에도 불구하고 Ramda는 적절하게 활용될 때 강력한 도구임은 부인할 수 없어요.

이 도구는 기능 프로그래밍에 완전히 헌신된 프로젝트에서 정말 빛을 발합니다. 하지만 프로젝트가 서로 다른 코딩 스타일을 오가는 혼합 모델이라면 JavaScript와 Lodash를 사용하는 게 더 편한 선택이 될 수도 있어요. 목표는 가장 멋진 도구를 사용하는 것이 아니라 명확하고 효율적인 코드를 작성하는 것이라는 걸 기억해 주세요.

JavaScript는 기능 스타일을 손쉽게 처리할 수 있는 능력이 향상되어 지금껏 잘 작동해 왔고, Lodash 역시 너무 복잡함 없이 다양한 작업을 처리하는 데 탁월한 능력을 발휘해 왔어요.

프로젝트 전체에 일관된 코딩 스타일을 유지하는 것도 도움이 될 수 있어요. 이는 팀에 새로 합류한 사람이 빠르게 적응할 수 있도록 단합감을 가져다 주기 때문에 매우 중요합니다. 빠르게 적응하면 빠르게 기여할 수 있어요.



# 결론

Ramda는 분명 강점이 있고 함수형 프로그래밍 분야에서 중요한 위치를 차지하지만, 프로젝트에서 다양한 코딩 스타일을 사용하는 경우에는 항상 최적의 선택이 되지는 않을 수 있습니다. 이러한 상황에서는 현대 네이티브 JavaScript와 Lodash를 계속 사용하는 것이 더 나을 수도 있습니다. 궁극적으로, 우리의 목표는 단지 복잡한 도구만 사용하는 것이 아니라 효과적이고 명확한 코드를 작성하는 것입니다.