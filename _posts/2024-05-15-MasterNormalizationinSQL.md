---
title: "SQL에서 정규화 마스터하기"
description: ""
coverImage: "/assets/img/2024-05-15-MasterNormalizationinSQL_0.png"
date: 2024-05-15 11:19
ogImage: 
  url: /assets/img/2024-05-15-MasterNormalizationinSQL_0.png
tag: Tech
originalTitle: "Master 'Normalization' in SQL"
link: "https://medium.com/learning-sql/master-normalization-in-sql-38143c7760ff"
isUpdated: true
---





![이미지1](/assets/img/2024-05-15-MasterNormalizationinSQL_0.png)

![이미지2](/assets/img/2024-05-15-MasterNormalizationinSQL_1.png)

데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.

# 정규화 이해하기:




정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.

## 정규화를 사용하는 이유:

![MasterNormalizationinSQL_2](/assets/img/2024-05-15-MasterNormalizationinSQL_2.png)

정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 "왜 정규화를 배워야 하는지"에 대한 참고 자료를 가질 수 있게 됩니다.



데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:

### 1. 중복 최소화:

정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.

### 2. 업데이트 이상 방지:



변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.

## 3. 데이터 무결성 향상:

데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.

## 4. 쿼리 성능 향상:



정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.

## 5. 데이터베이스 유지관리를 간단하게:

정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.

## 6. 확장 가능성을 용이하게하는:



정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.

# 정규화 유형

정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:

## 1. 제1정규화(1NF):



1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:

- 각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.
- 열 내에 반복 그룹이나 배열이 없어야 합니다.
- 테이블의 각 셀에는 하나의 값만 있어야 합니다.

예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.

## 2. 두 번째 정규형 (2NF):



위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.

표가 2NF에 있다는 것은 다음과 같습니다:

- 1NF에 있습니다.
- 모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.

이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.

## 3. 세 번째 정규형 (3NF):



3NF에있는 테이블은 다음과 같습니다:

- 2NF에 있습니다.
- 이러한 종속성이 없습니다.

다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.

## 4. Boyce-Codd Normal Form (BCNF):



BCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:

- 3NF에 있어야 합니다.
- 모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.

여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.

## 5. 제4 정규형 (4NF):



4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.

## 6. 다섯 번째 정규 형태 (5NF):

5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.

# 주요 여정을 시작해봅시다!



그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.

# 제1정규형 / 1NF

제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:

예제:



학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:

![표](/assets/img/2024-05-15-MasterNormalizationinSQL_3.png)

예제의 문제점:

- 반복 그룹: "Courses" 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.
- 비원자적인 값: "Courses" 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.



이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.

## 1NF에서 재구성된 표:

![Restructured Table in 1NF](/assets/img/2024-05-15-MasterNormalizationinSQL_4.png)

설명:



- "Course" column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.
- 반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.

## 제2 정규형 / 2NF

제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:

예시:



책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:

![테이블 예시](/assets/img/2024-05-15-MasterNormalizationinSQL_5.png)

예시의 문제점:

- 테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.
- "AuthorName" 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.
- 이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.



## 2NF에 재구성된 테이블:

테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.

![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_6.png)

## 설명:



- Books 테이블에서 BookID가 기본 키(primary key)입니다.
- Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.
- Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.
- Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.
- Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.

## 제 3 정규형 / 3NF

제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:

예시:



직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.

다음은 이 예시에 관한 문제점입니다:

- 이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.



## 3NF로 재구성된 테이블:

테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.

![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_8.png)

설명:



- 사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.
- 부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.
- 매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.
- 원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.

# Boyce-Codd 정규형 (BCNF)

Boyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:

예시:



다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:

Issues with the Example:

- The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙
- The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.



## BCNF로 재구성된 테이블:

테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.

![BCNF 테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_10.png)

설명:



- Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.
- Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.
- 원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.

# 제4 정규형 / 4NF

4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:

예시:



프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:


![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_11.png)


예제의 문제점:

- 다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.
- 테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.



## 4NF에서 재구성된 테이블:

테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.

![Restructured Table](/assets/img/2024-05-15-MasterNormalizationinSQL_12.png)

설명:



- Projects 테이블은 ProjectID를 기본 키로 포함합니다.
- Employees 테이블은 EmployeeID를 기본 키로 포함합니다.
- Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.
- Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.
- 원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.

# 다섯 번째 정규 형식 / 5NF

다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:

예시:



학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:


| StudentID | StudentName | CourseID | CourseName | Grade |
|-----------|-------------|----------|------------|-------|
| 1         | Alice       | 1        | Math       | A     |
| 2         | Bob         | 1        | Math       | B     |
| 1         | Alice       | 2        | Science    | B     |


예제의 문제점:

- 표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.
- 예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.



## 5NF로 재구성된 테이블:

테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:

![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_14.png)

## 설명:



- 학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.
- 강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.
- 성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.
- 원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.

# 결론:
SQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.