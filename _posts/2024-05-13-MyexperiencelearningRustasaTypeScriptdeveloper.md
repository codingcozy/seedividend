---
title: "TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험"
description: ""
coverImage: "/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"
date: 2024-05-13 00:10
ogImage: 
  url: /assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png
tag: Tech
originalTitle: "My experience learning Rust as a TypeScript developer"
link: "https://medium.com/gitconnected/my-experience-learning-rust-as-a-typescript-developer-df3abebb5abb"
---


![My experience learning Rust as a TypeScript developer](/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png)

많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.

저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.

저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...



# 왜 Rust를 선택해야 할까요?

저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.

Rust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.

Rust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.



# 러스트 배우는 방법

다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.

다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.

러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.



유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.

본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.

# 컴파일러

Rust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!



TypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.

이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).

그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.

오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!



# 유형 시스템

모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.

그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.

그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 &str과 String으로 충분히 커버돼 있어요!)



물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.

## 메모리 할당

TypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.

Rust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.



예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.

```rust
let small_int = "127".parse::<i8>().unwrap();
```

parse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:

```rust
let small_int: i8 = "127".parse().unwrap();
```



이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 "128"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.

타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.

```js
const x = 10 as unknown as string;
```

이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!



그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.

# 오류 처리

다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.

```js
let parsed_int = submitted_str.parse::<i32>().unwrap();
```



여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.

우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:

```js
let parsed_int_result = submitted_str.parse::<i32>();

let parsed_int = match parsed_int_result {
    Ok(data) => data,
    Err(error) => panic!(
        "주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}",
        error
    ),
};
```

또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:



```js
let parsed_int_result = submitted_str.parse::<i32>();

let parsed_int = match parsed_int_result {
    Ok(data) => data,
    Err(error) => 0,
};
```

이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .

물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.

또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.



# 선택적 값

Rust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.

```js
interface User {
  _id: string;
  name?: string;
}

function sayHello(user: User) {
  return `Hello ${user.name}!`;
}
```

이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!



하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.

```rust
struct User {
  _id: String,
  name: Option<String>,
}

fn say_hello(user: User) -> String {
    let name = user.name;
    format!("Hello {name}!")
}
```

위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:

```rust
struct User {
  _id: String,
  name: Option<String>,
}

fn say_hello(user: User) -> String {
  let name: String = match user.name {
    Some(name) => name,
    None => "world".to_string(),
  };

  format!("Hello {name}!")
}
```



한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 "Hello undefined"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.

이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.

# 소유권과 대여

마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.



TypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.

```js
const arrayToBeMutated: string[] = ["d", "c", "b", "a"];
const arrayToBeCloned: string[] = ["d", "c", "b", "a"];

arrayToBeMutated.sort();
arrayToBeCloned.toSorted();

console.log(arrayToBeMutated);  // ["a", "b", "c", "d"]
console.log(arrayToBeCloned);   // ["d", "c", "b", "a"]
```

위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.

일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.



하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.

먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.

다음 코드는 오류를 발생시킵니다:

```js
let foo = 10;
foo += 10;
```



이 코드는 다음을 수행하지 않습니다:

```js
let mut foo = 10;
foo += 10;
```

이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.

예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:



```js
let mut nums: Vec<i32> = vec![1, 2, 3, 4, 5];
nums.push(6);
```

러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:

```js
let nums: Vec<i32> = vec![1, 2, 3, 4, 5];
let doubles: Vec<i32> = nums.into_iter().map(|n| n * 2).collect();

dbg!(nums);     // 이 코드는 오류를 발생시킵니다.
dbg!(doubles);
```

위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 "소비형 반복자(consuming iterator)"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.



nums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.
간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.

```js
fn main() {
    let str = String::from("Hello world!");
    let len = calculate_length(str);
    dbg!(str); // 오류 발생
}

fn calculate_length(s: String) -> usize {
    s.len()
}
```

여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 &를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:



```rust
fn main() {
    let str = String::from("hello");
    let len = calculate_length(&str);
    dbg!(str, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!

내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.

Rust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!
