---
title: "오프라인 사용 가능한 웹 애플리케이션 개발하기"
description: ""
coverImage: "/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png"
date: 2024-05-14 12:54
ogImage: 
  url: /assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png
tag: Tech
originalTitle: "Developing Offline-Ready Web Applications"
link: "https://medium.com/stackademic/developing-offline-ready-web-applications-05b2f30c120e"
---


![IMG](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_0.png)

네, 제목을 제대로 읽으셨어요. 대부분의 웹 애플리케이션에서는 네트워크 접근이 가능할 것이라는 내제적인 가정이 있습니다. 사이트가 서버 측 렌더링, 정적 생성 또는 브라우저를 통해 완전히 작성되었는지에 상관없이 HTML, CSS 및 JS는 네트워크를 통해 HTTP 요청을 통해 가져옵니다. 각 페이지가 로드될 때 추가 리소스를 가져오거나 타사 API와 통신할 수 있습니다. 네트워크 탭을 빠르게 살펴보면 사이트가 대화형임을 알 수 있습니다. Google Analytics 이벤트부터 Stripe 위젯, 버그 추적 소프트웨어까지, 단일 페이지가 사용자 입력 없이도 계속 네트워크에 액세스할 수 있습니다. 기본적인 가정에 도전했을 때 어떻게 해야 할까요? 네트워크가 사용할 수 없을 때 웹 개발자로서 사용자에게 어떻게 서비스를 제공할 수 있을까요?

# Service Workers - 오프라인 문제에 대한 해답

이 문제를 해결하기 위해 Google, Samsung, Mozilla 및 기타 회사들이 협력하여 2014년 5월에 서비스 워커의 W3C 초안을 처음 소개했습니다. 그 전에 기본적인 웹 워커를 살펴보겠습니다 - 주 프로그램의 “백그라운드"에서 실행되는 JavaScript 파일입니다. 웹 워커는 자체 스레드를 가지고 있지만 주 JavaScript 스레드와 계속 통신할 수 있습니다. 이 별도의 스레드를 통해 주 프로그램의 코드 실행을 차단하지 않으면서 백그라운드에서 계산적으로 비용이 많이 드는 작업을 수행할 수 있으므로 사용자 경험을 방해하지 않습니다. 웹 워커는 현재 창과는 별개의 컨텍스트에서 실행되며 DOM이나 창 객체에 액세스할 수 없습니다.



## 서비스 워커란

서비스 워커는 귀하의 사이트와 제삼자 간에 프록시처럼 작동하는 전문화된 웹 워커입니다. 요청이 서비스 워커에 의해 가로채지며 응답은 그를 통해 라우팅됩니다. 서비스 워커는 원본과 경로 또는 패턴(URL의)에 바인딩되어 해당 원본에서 발생하는 이벤트(예: fetch)에 응답합니다.

![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_1.png)

이 경로 또는 패턴은 서비스 워커의 범위와 관련이 있으며 등록된 경로 및 해당 경로 내의 모든 중첩된 경로를 포함합니다. 서비스 워커가 mysite.com/puppies/sw.js에서 등록된 경우 mysite.com/puppies/labs 및 mysite.com/puppies/boxers에 대해 작동합니다. 이는 서비스 워커가 실행되는 범위이며 한 범위에는 하나의 서비스 워커만 등록될 수 있습니다. 그러나 선택적으로 이 기본 범위를 좁힐 수 있습니다.



웹 워커들과는 다르게, 서비스 워커들은 시간 제한이 있어서 밀리초 단위로 생성되어 작업을 수행한 뒤 소멸될 수 있습니다. 이러한 의도적으로 짧은 수명은 스크립트 내에서 전역 상태에 의존하는 것을 불가능하게 만듭니다. 대신, 이들은 브라우저의 IndexedDB나 캐시 API에 기본 액세스 권한을 부여받아 데이터를 저장하고 검색할 수 있습니다.

![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_2.png)

서비스 워커는 보완 기능으로서, 비공식 브라우저에서도 여전히 사이트의 모든 콘텐츠에 액세스할 수 있습니다. 그리고 그 보완 기능은 광범위합니다 — 캐싱, 백그라운드 동기화, 푸시 알림 및 오프라인 기능을 포함합니다.

## 서비스 워커 생명 주기



서비스 워커에는 라이프사이클이 있어 엔드 사용자의 브라우저와 상호작용하는 방식을 규정합니다. 서비스 워커가 등록되고 설치될 때까지 클라이언트로의 네트워크 흐름을 제어하지 않습니다. 심지어 서비스 워커도 해당 범위로의 다음 탐색으로 들어가기 전까지 요청을 프록시로 전달하지 않습니다.

- 등록 — 이 첫 번째 단계는 사용자가 서비스 워커의 범위 내에서 URL을 입력할 때 발생합니다. 서비스 워커는 브라우저가 지원되는지 확인하고, 그렇다면 등록 함수가 호출되어 스크립트의 URL을 범위에 연결합니다. 대부분의 모던 브라우저에서 애플리케이션 탭의 개발자 도구에서 서비스 워커 등록을 확인할 수 있습니다. 주어진 서비스 워커에 대해 최대 한 번만 발생할 수 있는 단계입니다.
- 다운로드 — 등록이 성공하면 서비스 워커가 클라이언트 브라우저로 다운로드됩니다. 사용자로부터 권한을 요청하지 않고 백그라운드에서 조용히 진행됩니다. 업데이트 후 다운로드가 진행되면 이전 서비스 워커 코드와 최신으로 다운로드된 코드 간의 바이트 단위 비교가 이루어집니다. 다른 경우 설치가 진행됩니다.
- 설치 — 새로 다운로드된 서비스 워커 파일이 있으면 설치가 시작됩니다. 범위로 처음으로 서비스 워커가 다운로드된 경우 즉시 활성화됩니다. 업데이트 이후 설치가 발생하면 즉시 활성화되지 않고 대기합니다.
- 대기 — 이는 업데이트 중에만 발생합니다. 이전 서비스 워커는 클라이언트의 프록시로 계속 작동하며 현재 서비스 워커를 사용하는 웹 페이지가 더 이상 없을 때까지 기다립니다. 그러나 대기 기간을 건너뛰기 위해 특정 함수를 호출함으로써 대기를 우회할 수도 있습니다.
- 활성화 — 대기 또는 설치 직후에 활성화 이벤트가 발생하며 그 순간 캐시를 정리하거나 다른 작업을 실행할 수 있습니다.
- 업데이트 — 사용자가 서비스 워커의 범위 내 페이지로 돌아가거나 등록 함수가 호출되거나 이벤트가 발생하지만 지난 24시간 동안 업데이트가 발생하지 않은 경우 업데이트가 발생합니다. 업데이트 중에 단계 2~5가 반복됩니다 (단계 2, 3은 기울임꼴로 표시됨).

![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_3.png)

## 서비스 워커가 오프라인 웹 사이트를 가능하게 하는 방법



서비스 워커는 프록시로 작동합니다. 이 서비스 워커는 fetch 이벤트에 접근을 제공하여 다양한 조건에 따라 애플리케이션의 동작을 변경할 수 있게 해줍니다. 또한 강력한 캐싱 API를 가지고 있습니다.

뉴욕시에 사는 사용자라고 상상해봅시다. 지역 유기농 식품을 판매하는 웹사이트를 둘러보고 지하철에 올라탔더니 신호가 끊겼습니다. 갑자기 고장난 웹페이지가 보입니다. 사이트를 새로고침해봐도 고장나 있습니다. 뒤로 가기 버튼을 눌러봐도 여전히 고장났습니다. 서비스가 없다면 브라우저의 HTTP 요청은 어떤 API에도 전달되지 않습니다. 페이지가 로드되지 않고, 양식이 전송되지 않습니다 — 오프라인 상태입니다. 이런 상황을 우리는 모두가 사용자로서 경험해봤습니다.

![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_4.png)

이제 이 웹사이트가 서비스 워커를 활용한다고 상상해봅시다. 이제 지하철에 들어가서도 웹사이트를 계속해서 둘러볼 수 있습니다. 경험은 매끄럽습니다 — 하지만 숨긴 데이터 불일치가 있을 수 있습니다. 양식을 제출해보려고 하면 오프라인임을 알려주고 나중에 다시 시도하라는 메시지가 표시됩니다 (PWA를 통해 연결이 다시 활성화되면 이 양식이 전송될 수 있습니다, 아래 참조). 바 현황을 한번 봐보시면, 맞습니다 — 오프라인입니다. 언제 그런 일이 발생했을까요?



사용자에게 완벽한 경험이 아니더라도, 고장난 웹페이지보다 훨씬 나은 것입니다. 특히 이는 블로그와 같이 다양한 상호작용이 불필요한 사이트에 이상적입니다. 이는 서비스 워커 캐시를 활용하여 구현됩니다. 네트워크 요청이 전송되면 서비스 워커가 데이터나 페이지를 캐시할 수 있습니다. 네트워크 연결이 끊어진 경우, 캐시로부터 해당 페이지를 제공하여 사용자에게 더욱 편리한 경험을 제공할 수 있습니다.

# 서비스 워커와 PWA

우리는 이미 서비스 워커가 최종 사용자에게 오프라인 접근성을 제공하는 방법을 명확히 알아보았습니다. 그런데, 그 외에도 어떤 일을 할 수 있을까요? 이것은 관련 개념인 점진적 웹 애플리케이션(Progressive Web Applications, PWAs)로 이어집니다.

PWA는 웹 기반 앱이지만 기기에서 네이티브 애플리케이션과 유사한 경험을 제공합니다. 다른 웹사이트와 마찬가지로 기본적인 HTML, CSS, JS로 작성되어 창에 액세스할 수 있고 API에 네트워크 요청을 보낼 수 있습니다. 그러나 다른 웹사이트에는 없는 강력한 기능이 여러 가지 있습니다.



## PWA를 설치할 수 있습니다

일반 웹사이트와는 달리 PWA는 웹 앱 매니페스트의 명세에 따라 설치할 수 있습니다. 이를 통해 브라우저에 설치할 방법을 알려줍니다. 매니페스트에는 설치된 PWA의 경험을 사용자 정의하는 데 많은 특성을 포함할 수 있습니다.

또한, 설치된 PWA는 앱과 같이 기기에 아이콘이 표시됩니다. 브라우저에 액세스하지 않고도 실행할 수 있으며 독립적인 애플리케이션으로 작동합니다. 어떤 경우에는 앱 스토어에서 직접 설치할 수도 있습니다.

## Service Workers가 PWA와 통합되는 방법



PWA의 많은 기능은 서비스 워커 덕분입니다. 서비스 워커는 PWA에서의 외부 요청을 위한 프록시 역할을 계속하며, 브라우저에 의해 활성화되어 사용자가 PWA와 상호 작용하지 않아도 백그라운드에서 실행될 수도 있습니다.

서비스 워커의 양방향 통신과 프록시 기능의 존재는 다양한 유용한 기능을 제공합니다.

- 브라우저를 통해 구독한 사용자에게 푸시 알림을 보내고, 이를 서비스 워커를 통해 클라이언트 장치에 표시할 수 있습니다.

![이미지](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_5.png)



- 사용자가 응용 프로그램과 상호 작용하지 않을 때 배경에서 사이트 상태를 업데이트합니다. 예를 들어, 사용자가 응용 프로그램을 열 준비 중인 경우에 계산이 많이 필요한 엔드포인트를 호출하여 수분이 끊김없이 이루어지도록 합니다.
- 연결 가능 상태가 되면 보낼 메시지를 저장합니다.
- 연결이 실패할 때 표시할 정적 웹페이지의 캐시된 버전을 보관합니다.
- 연결 상태에 따라 UI의 수분을 변경합니다. 예를 들어, 동적 전자 상거래 사이트를 구축 중이라면, 장바구니의 마지막 알려진 버전, 사용자의 기본 프로필 및 기타 쉽게 저장할 수 있는 정보를 표시합니다.

이러한 예들은 PWA가 기본 웹 애플리케이션보다 신뢰성이 높고 성능이 우수한 것을 보여줍니다. 캐싱 API와 서비스 워커를 통해 제공되는 양방향 통신은 많은 개선을 제공하기 때문에 PWA가 왜 더 보급되지 않는지 궁금할 정도입니다...

## 아니면 그렇지 않나요?

이 기사를 통해 PWA에 대해 처음 들었거나 기기에 PWA가 하나도 설치되지 않았다면, 모든 브라우저에서 지원되지 않고 모든 기기에서 풀 네이티브 기능을 갖추고 있지 않기 때문일 것입니다 (Apple씨, 여기서 얘기하는 건 당신입니다). 이것은 새로운 개념이 아닙니다. 2007년에는 스티브 잡스가 처음으로 "웹 2.0 앱"을 대중화하고 첫 번째 iPhone을 출시하면서 네이티브 앱을 쉽게 지원하지 않았습니다. Forbes가 후에 그것을 그의 가장 큰 실수라고 표현하기도 했습니다. 그 당시 이러한 웹 애플리케이션은 Facebook 및 기타 회사에 의해 개발되었지만, 그들의 성능은 단순히 네이티브 앱과 비교할 수 없을 정도로 좋지 않았습니다. 이것은 대부분 현재 서비스 워커가 제공하는 능력 부족 때문이었습니다.



![개발 중인 오프라인 준비 웹 애플리케이션](/assets/img/2024-05-14-DevelopingOffline-ReadyWebApplications_6.png)

애플은 빠르게 방향을 바꿨어요. 오늘날, 그들이 애플 스토어에서 누적된 수익을 보호하기 위해 PWA에 대한 완전한 네이티브 지원을 제공하는 데 느리게 움직인 것으로 추정됩니다. 애플 제품을 사용해본 적이 있다면, 하나의 기기를 구입한 후 애플 제품이 바이러스처럼 자동으로 늘어난 것을 알 수 있을 거에요 — 헤드폰, 컴퓨터, 코드, 시계, 아쉽게도 앱까지. 제가 사용하는 것도 정말 그랬어요. 모두가 매끄럽게 함께 작동하기 때문에 더 편리하죠. 그러나 이에는 PWAs를 완전히 활용할 기회를 놓치는 것과 같은 단점이 따릅니다.

애플과 사파리를 제외하고 파이어폭스도 PWAs에 대한 완전한 지원을 채택하는 데 더 느렸어요. 실제로 오늘날까지도 iOS에서 PWA에 대한 지원이 없습니다. 크로미엄 기반 브라우저는 다른 어떤 브라우저보다 빨리 PWA를 지원했어요. 이는 구글 엔지니어들이 2015년에 처음으로 'Progressive Web Application'이라는 용어를 만든 것이기 때문에 놀라운 일이 아니에요.

지난 시간 동안 완전한 채택이 느리게 진행되어 왔지만, 상황이 빠르게 변화하고 있습니다. 올해 초 애플은 일부 기기에서 푸시 알림을 허용하기 시작했어요. 게다가 서비스 워커가 지속적으로 개선되고 새로운 기능들이 계속해서 제공되고 있어요.



이것이 미래의 방향이 될 수 있을까요? 결국, 네이티브 응용 프로그램을 웹사이트와 연결할 때 전용 프로그래밍 언어와 생태계를 왜 굳이 사용해야 할까요? 기본 웹 도구를 사용하고 사용자에게 향상된, 거의 네이티브 경험을 제공할 수 있기 때문에요. 단점과 위험도 있고, 네이티브 앱은 여러 면에서 우위를 지니고 있지만요. 그러나 웹 기술과 속도가 계속 발전함에 따라, 근시일안에 많은 프로그레시브 웹 앱을 더 많이 보게 될 것이라 예상합니다.

# Stackademic

끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:

- 박수를 보내주시고 저자를 팔로우해주시길 바랍니다! 👏
- 트위터(X), 링크드인, 유튜브에서 팔로우해주세요.
- Stackademic.com 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많은 정보를 얻으세요.