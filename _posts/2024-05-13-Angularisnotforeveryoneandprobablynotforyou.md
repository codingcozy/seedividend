---
title: "앵귤러는 모두를 위한 것이 아닙니다, 아마도 당신을 위한 것도 아닐 것입니다"
description: ""
coverImage: "/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png"
date: 2024-05-13 00:13
ogImage: 
  url: /assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png
tag: Tech
originalTitle: "Angular is not for everyone, and probably not for you"
link: "https://medium.com/@maks-dolgikh/angular-is-not-for-everyone-and-probably-not-for-you-72e4766fff20"
isUpdated: true
---




![이미지](/assets/img/2024-05-13-Angularisnotforeveryoneandprobablynotforyou_0.png)

2023년, Angular 팀은 커뮤니티에서 요청한 중요한 변경 사항들을 많이 반영했고, 정말 멋진 일이죠. 하지만 항상 그랬던 것은 아니었습니다.

이 이야기에서 나는 4년 동안 Angular을 사용하면서 얻은 경험에 대해 이야기하고 싶습니다.

우선, Angular은 애플리케이션을 개발하는 데 처음으로 선택할 기술이 되지 않아야 한다고 생각합니다.



앵귤러가 발생시키는 문제와 개발자 및 팀 빌딩에 미치는 영향을 강조하고 싶어요. 이를 식별한 문제들에 대한 해결책도 제시하려고 해요. 이미 앵귤러를 사용하거나 사용하고 싶다면 도움이 될 거예요.

아쉽게도 어떤 이유로 인해 일부 팀이나 회사들은 업그레이드를 미루는 경우가 있어요. 따라서 여기서 설명한 일부 문제는 여전히 관련이 있을 수 있어요.

신입 개발자라면 이 글이 유용할 것이며 여러분이 첫 개발 스택을 선택하는 데 도움이 될 걸 거예요.

# 편리함의 함정



앵귤러는 라이브러리가 아닌 UI 프레임워크로 알려져 있어요. 앵귤러는 프론트엔드 애플리케이션 개발에 대한 자체 포괄적인 솔루션으로 위치하고 있어요. 앱마다 "기술의 동물원"같은 것은 없고, 모든 것이 일관되고 단조로운데, 이에는 단점도 있어요. 앵귤러가 제공하는 편의성에 익숙해지면, 나중에 그것들을 포기하기가 더 어려워질 수 있어요.

## ReactiveForms

한 때, 앵귤러 팀이 제안한 접근 방식, 폼과 해당 컨트롤을 HTML 템플릿과 JS 컨트롤러로 분리하는 것은 정말 폼 개발에 편리했던 것이 증명되었어요.

그 문제는 다르네요. ReactiveForms에서 제공하는 유효성 검사에 의지하는 것에 너무 익숙해져서, HTML이 입력 필드를 유효성 검사하는 데 필요한 모든 속성을 제공한다는 것을 잊어버리곤 해요 — min, max, pattern, required, read-only 등.



이 문제는 무엇인가요? — Angular을 넘어서면 ReactiveForms이 독립 라이브러리로 존재하지 않는다는 것을 알게 됩니다. 폼 개발 방법을 다시 배워야 할 것입니다 — 이벤트 (제출, 변경) 및 입력 필드 속성.

## 애플리케이션 빌드

애플리케이션 빌드를 사용자 정의할 필요가 없습니다. 그냥 "build" 또는 "serve" 명령을 실행하여 시작하면 됩니다. 빌더의 webpack.config.js 또는 vite.config.js 구성 파일을 보지 못할 것입니다.

네 말씀하세요:



- 어떻게 귀하의 애플리케이션이 구성되었나요?
- 어떤 파일이 진입 지점인가요?
- 어떤 도구가 귀하의 애플리케이션을 빌드하나요?
- SCSS 파일이 CSS로 변환되는 방법은 무엇인가요?
- HRM은 어떻게 작동하나요?

Angular만 사용하면 애플리케이션을 빌드하는 기술을 키우는 성장 단계를 놓치게 될 거예요. Webpack, Gulp, Rollup, Vite, Esbuild 등에 대해 알지 못할 거예요. 만약 Angular 없이 HTML과 SCSS로 간단한 웹 페이지를 만들라고 하면, 아마 할 수 없을 거예요.

## HTTP 클라이언트

이것은 최근 XHR2 기능을 활용하여 Observable 패턴을 사용하는 XHR을 감싸주는 편리한 래퍼입니다. 이것을 통해 다중 매개변수로 쿼리를 생성하고, 쿼리의 진행 상황을 추적하며, 단 하나의 매개변수로 응답을 원하는 데이터 유형으로 변환할 수 있습니다.



하지만 앵귤러 개발자로서 다음을 말할 수 있나요?

- 네이티브 메서드(fetch 또는 XHR)를 사용하여 최근 HTTP를 처리한 적이 있나요?
- 인터셉터를 사용하지 않고 전역적으로 요청과 오류를 처리할 수 있나요?
- switchMap을 사용하지 않고 HTTP 요청을 되돌릴 수 있는 방법을 말할 수 있나요?
- axios나 node-fetch 라이브러리를 알고 있나요?

편의성은 좋지만, 앵귤러 없이 쿼리를 작성하는 방법을 알아야 합니다. 심지어 시니어 개발자도 부트스트랩 애플리케이션을 시작하기 전에 요청을 보내는 방법을 모르거나 RxJS.Ajax의 존재를 모르는 것에 놀라곤 합니다.

요청과 응답의 본질에 대한 이해가 있어야 다음과 같은 작업을 수행할 수 있습니다:



## 테이블을 마크다운 형식으로 변경

- 에러 처리
- 응답 분석
- 요청 진행 상황 추적
- FormData와 함께 작업

# Zone.js

Angular의 신기함과 골칫거리. Zone.js는 모든 브라우저 이벤트를 위임하고 그 후 Angular에게 알릴 도구로 소개되었습니다. 그 목적은? — 업데이트의 "마법"을 제공하기 위해서:

- 마우스 클릭? — 업데이트
- 요청 종료? — 업데이트
- setTimeout 종료? — 업데이트



전체 애플리케이션이 어떻게 업데이트되는지에 대해 생각해 본 적이 없죠. 그러나 이 프로세스를 이해하지 못하면 미래의 최적화에 큰 문제가 될 수 있습니다.

루트 및 자식 존, 기본 및 OnPush, runOutsideAngular, ComponentsTree, ViewTree, Async-pipe 등 다양한 생각할 수 없는 주제와 라이브러리 변경 감지에 대한 글들이 많이 쓰였습니다.

이 글들은 "용기를 잡는 법"을 이해하기 위해 필요한 것뿐입니다. 네, ChangeDetectorRef나 NoopZone를 통해 컴포넌트 및 애플리케이션 업데이트를 간접적으로 관리할 수 있지만, 이것은 편리함이 아니라 유지 관리 과제입니다.



# 앵귤러는 RxJS를 제공했지만 어떻게 사용해야 하는지 알려주진 않았어요

앵귤러에서 RxJS에 관한 가장 빈발한 주제는 무엇일까요? - 구독 관리와 메모리 누수입니다. 그리고 이게 아무 이유 없는 얘기가 아니에요.

앵귤러에서 개발을 시작하는 개발자들은 Observable을 Promise처럼 then()으로 처리하려고 해요. 많은 멋진 코드와 좋지 않은 구현을 봤어요. RxJS에 대한 지식이 없으면 앵귤러에서 효과적으로 작업할 수 없기 때문에 강좌와 자료를 만드는 이유를 이해해요.

일반적으로 알려진 앵귤러는 반응적인 접근이 아니라 스트림 접근에 관한 것이에요. 모든 값들은 '스트림'이에요. 스트림으로 생각하고 스트림과 어떻게 작업할지 알지 못한다면 어려움을 겪을 거에요.



2024년에도 이런 주제들이 면접에서 확인됩니다:

- 고차 연산자 — concatMap, mergeMap, switchMap, exhaustMap
- 결합 연산자 — zip, forkJoin, combineLatest
- 메모리 누수 모니터링
- "Hot"과 "cold" Observables
- takeUntil, takeWhile, takeUntilDestroyed(new)

## RxJS의 사로잡힌 자

Angular에서 스트림과 함수형 프로그래밍으로 마음가짐을 전환했다 하더라도, 모든 값이 스트림이 될 수 있는 것은 아니라는 점을 주의하세요.



문제가 무엇인가요? — 기본형과 객체를 다루는 법을 까먹었나요? 이제는 필요하지 않은 값이 스트림에 있습니다. BehaviorSubject를 통해 모든 클래스 필드를 생성하려는 충동이 생길 것입니다. 이것은 큰 문제입니다. 이로 인해 여러 조합과 내부 구독을 가진 각 필드에 대해 10개 이상의 BehaviorSubject가 있는 상태 서비스의 많은 구현을 볼 수도 있습니다.

# DI

많은 개발자가 Angular를 선택하게 만드는 기능입니다. 하지만 스스로 발목을 쏘지 않는 방법을 알아야 합니다.

## ProvidedIn과 사용하지 않는 코드



@Injectable 데코레이터에서의 ProvidedIn 함수는 Angular에 서비스를 등록해야 하는 위치를 알려주는 용도로 만들어졌어요. 이를 통해 초기 스크립트의 크기를 최적화할 수 있었고, 필요하다면 사용되지 않는 서비스를 빌드에서 제거할 수도 있었죠. 이 접근 방식은 라이브러리 개발에 사용할 수 있어요. 여러분이 만든 라이브러리에서 다른 개발자가 얼마나 많은 서비스를 사용할지 모르는 경우에 유용해요.

하지만 이 방식은 단일 앱을 갖는 통합형 저장소에는 적합하지 않아요. Angular가 불필요한 코드를 제거해주는 것은 좋지만, 코드베이스를 최신 상태로 유지하는 책임을 Angular에게 넘기게 된다는 문제가 있어요.

## 제공의 마법

ProvidedIn은 모든 서비스를 자동으로 등록해주는데, 이 부분은 편리한 면이 있어요. 하지만 providedIn: root를 사용할 때 문제가 발생하기 시작해요.



개발자들은 트리 쉐이킹 메커니즘에 매우 의지하고 있습니다. 이에 따라 응용 프로그램의 일부분에서만 사용되는 서비스도 리포지토리의 가장 깊은 곳에서 전역으로 등록합니다. 이렇게 하면 전역적인 요소를 만들어 리포지토리 구조를 파괴하게 된다는 점을 명심해주세요.

## 서비스의 트리 쉐이킹은 코드의 트리 쉐이킹과 같습니다

많은 사람들이 서비스의 트리 쉐이킹이 코드 전체에 적용되는 것으로 잘못 알고 있지만, 실상은 그렇지 않습니다.

ProvidedIn은 프로바이더 트리의 생성 및 그 안에 포함될 서비스의 수에만 영향을 줍니다. 최대로 절약할 수 있는 용량은 전체 빌드 중 10-15 kb로 매우 작은 값입니다.



# 항상 현재 프론트엔드 기능의 뒤쳐지게 될 거에요

Angular은 '프론트엔드 세계'에서 애플 제품으로 생각해야 합니다. 다른 브랜드들이 몇 달에 한 번씩 새로운 기능을 결합하고 개발하는 동안, 애플은 새로운 기능을 서둘러 추가하지 않고 제품을 연마다 조금씩 개선하는 것을 선호해요.

Angular의 종속성이 닫힌 생태계를 가지고 있어, 어떤 종속성을 새로운 것으로 교체하는 것이 어려울 수 있어요. 중요한 것은 Angular 버전을 최신으로 유지해야 한다는 점이에요. 예를 들어, Angular 9에서 Typescript 5나 Webpack 5를 사용할 수 없어요 — 올바른 버전으로 업그레이드해 주세요. 업그레이드를 실패하거나 미룰 경우, 모든 기능이 그대로 지나가게 될 거에요.

Angular 팀이 기대하는 기능이나 도구 지원을 추가하지 않기로 결정하면, 그대로 사용해야 할 수 있습니다. 영원히 무엇을 가지고 작업해야 할지도 모를 거에요.



# 더 많은 사람 — 더 많은 아이디어 — 더 많은 해결책

Angular는 현재 앱 개발을 위한 세 가지 가장 인기 있는 기술 중 하나입니다.

만약 React나 Vue로 어플리케이션의 복제본을 구현하려고 한다면, 이 어플리케이션의 모든 종속성이 Angular에서는 대응하는 것이 없다는 것이 드러날 것입니다. 그것들은 존재하지 않거나 js 라이브러리에 대한 Ng-wrapper가 없거나 그런 래퍼가 있더라도 다른 기능을 가지고 있을 수 있습니다.

React나 Vue보다 커뮤니티가 작아서 이러한 도구들을 만들지 않았기 때문에 자체 솔루션을 구현하는 데 시간이 걸릴 것입니다.



# 개발자 편의가 비즈니스보다 앞섭니다.

인기 있는 도구와 Angular을 비교하는 모든 글과 토론은 내부 구현에 대해 이야기하지만 한 가지를 잊고 있습니다 — 성능, SEO, 빌드 크기 및 그 결과를 달성하는 데 소요된 시간이 동일할 때만 도구를 비교해야 한다는 것을 잊습니다.

우선, 당신은 제품을 개발하는 대신 돈을 지급하는 비즈니스를 위해 일하고 있습니다. 최종 사용자는 제품을 누가 만들었는지, 몇 명이 만들었는지, 어떤 기술로 만들어졌는지는 모릅니다. 그가 중요하게 생각하는 것은 응답성이 뛰어나고 예상대로 작동하는 빠른 사이트입니다.

"모든 것을 갖췄다"는 마인드셋으로 Angular을 선택하면 초기 개발 단계에 빠르게 진입할 수 있을 뿐입니다. 당신은 의도적으로 개발 옵션을 좁혀 선택해야 할 것이며 이제 Angular이 제공할 수 있는 것에 의존해야 합니다. 2018년이 아니라는 것을 명심하세요. 숙련된 개발자는 1~2시간 만에 프로젝트를 처음부터 만들 수 있고 미래 제품의 요구사항을 반영하는 도구 스택을 선택할 수 있습니다. 무언가 변경되면 어떤 부분이든 더 나은 것으로 대체할 수 있습니다.



프론트엔드 개발자이시군요! 먼저 표 태그를 마크다운 형식으로 변경해주세요.

그리고 Angular를 선택한다면, 도구의 인기와 개발자 수는 직접적으로 연관되어 있기 때문에 새로운 인재를 찾는 것이 더 어려워질 수 있다는 것을 염두에 두는 것이 좋습니다. 비즈니스 전략이 신속한 성장을 포함한다면, 후보자를 찾을 가능성을 높일 수 있는 보다 인기있는 도구를 살펴보세요.

# Angular는 필요 없는 것을 사용하라고 제안합니다

## Protractor

이게 무엇인지 모른다면 괜찮아요. 이것은 최근까지 Angular 작업 공간을 생성할 때 설치되었던 e2e 테스트 도구입니다.



이 솔루션을 사용한 개발자가 매우 적다는 것을 쉽게 짐작할 수 있습니다. 또한, 이 도구에 대한 문서, 안내서, 지침도 거의 찾아볼 수 없을 것입니다.

일반적으로 저장소에 e2e 테스트가 필요하면 익숙한 Cypress나 Puppeteer 도구로 마이그레이션하는 방법을 찾았습니다.

## Karma + jasmine

Angular 패키지에서 기본적으로 제공되는 또 다른 도구입니다. Protractor와 달리 사용이 중단되지 않았으며 개발자들 사이에서 인기가 있습니다.



Jest는 종종 이 조합과 대조됩니다. 테스트 작성에는 특별한 차이가 없지만 구성 방식과 일반적인 작업 방식이 다를 수 있습니다.

Karma + Jasmine을 사용하기 전에 몇 가지 질문에 답해 보세요:

- Jest를 알고 대체 도구로 전환할 준비가 되었나요?
- 테스트를 실행하기 위해 브라우저 기반 환경이 실제로 필요한가요?
- Karma와 생태계를 사용자 정의할 준비가 되었나요?
- CI/CD에서는 에이전트에 브라우저를 설치하여 Karma에서 테스트를 실행해야 한다는 것을 알고 계셨나요?

## Angular Material



기본적으로 내장된 종속성은 아니지만, 이 라이브러리를 우회할 수 없는 것은 정말 어렵습니다.

개발자들과 팀들이 다른 UI 라이브러리 대신 Angular Material을 선택하는 주된 이유 중 하나는 공식 Angular 팀의 지원입니다. 다른 UI 라이브러리는 새로운 Angular 버전이 출시되길 기다리고 업데이트를 기다리지만, Angular Material은 거의 Angular과 동시에 출시됩니다. 이 시점에서는 Angular Material을 지지하는 어떤 주장도 없어지죠.

익숙해지기까지 다소 복잡한 개발용 도구입니다:
- 스타일링. 컴포넌트 스타일링을 추천하는 방식을 따르지 않으면 이 라이브러리와 별개의 문제가 됩니다. Angular Material은 css 선택자를 변경하거나 요소의 중첩 순서를 일방적으로 변경할 수 있으므로 이에 대비해야 합니다.
- Angular 업그레이드. Angular Material 번들의 경우, Angular의 새 버전으로 처음 업그레이드하는 것은 불가능할 수 있습니다. 빌드를 가지고 있더라도 인터페이스가 원래 렌더링을 유지할 것이라는 보장은 없습니다. 그에 따라 회귀 또는 QA가 필요합니다. 이에 대한 리소스가 없는 경우, 모든 것을 개인적으로 직접 확인해야 할 준비가 필요합니다.
- 컴포넌트의 사용자 정의 감소. Taiga-UI와 같은 다른 라이브러리는 각 엔티티를 사용자 정의할 수 있는 도구와 방법의 많은 목록을 제공하는 반면, 여기서는 컴포넌트를 처음부터 구현하거나 ViewChild를 사용하여 컴포넌트를 필요에 맞게 관리해야 할 것입니다.



# Angular Universal

저에게 있어서 Angular의 SSR을 사용하는 것은 컴포넌트 렌더링 버그를 고치는 게으른 방법입니다 (잊혀진 trackBy, ChangeDetection.Default, Critical CSS 등) 그리고 초기 빌드 크기도 통제하는 방법이에요.

Angular Hydration이 추가되기 전인 16 버전 이전에는 Angular의 SSR 사용을 무의미하게 생각할 수 있어요.

먼저 Angular은 대규모 기업 애플리케이션을 위한 도구에요. 랜딩 페이지, 포트폴리오 페이지 또는 다른 "가벼운" 앱을 만들 때 선택하는 것이 아니에요. Angular를 선택했다면, 최적의 SEO나 FCP를 가진 애플리케이션을 만드는 관점에서 출발하기 어렵겠네요. 이미 알고 있듯이 최종 Angular 빌드는 다른 라이브러리보다 크게 될 거라고 가정하고 시작하는 거죠.



## SSR이 필요해질 때 언제든지 라인

의외로도 당신의 Angular 애플리케이션이 SSR을 가지고 있지 않더라도 SSR을 위해 개발해야 합니다. 전역 API인 window를 포함하여 서버 환경에는 존재하지 않는 것들을 토큰화해야 합니다. 이 접근 방법에는 문제가 없지만, 이 사실을 알고 서로 지키는 Angular 개발자가 얼마나 되겠습니까?

브라우저에서만 작동하는 기능이나 도구를 사용하는 경우, SSR을 추가하여 즉시 애플리케이션을 실행할 수 없게 됩니다. 현재 애플리케이션을 위해 SSR을 지원하는 과정에서 시간과 리소스를 낭비하게 되며, 여러 버그를 만들 수도 있습니다.

## 유연성 제로



이제 가장 최근에 소개된 Angular Hydration을 가지고 있지만, Qwik와 Resumability에 대해 배웠습니다. 이 지식을 활용하여 Angular 내에서 재현할 수 있을까요? — 아닙니다. 여러분의 경험을 모두 갖고 있더라도, Angular 팀이 Angular Universal에 대한 지원을 추가하기를 결정할 때까지 사용할 수 없습니다.

# 결론

각 개발자는 다른 개발자가 만든 다른 기술을 사용하는 소비자입니다. 가장 중요한 것은 자신이 편안한 느낌을 가질 수 있는 장소를 찾는 것입니다.

첫 번째 스택을 형성할 수 있는 방향을 찾는 초보 프론트엔드 개발자라면, Angular를 포기하는 것이 더 나을 수 있습니다. 네이티브 JS 및 HTML 기능에 기반을 둔 React, Vue, Svelte 또는 기타 가벼운 UI 라이브러리를 선택하는 것이 더 낫습니다. 엄격히 규제된 종속성이 없기 때문에 특정 작업에 어떤 도구를 적용할지 스스로 결정할 수 있습니다. 이를 통해 할당된 작업의 범위 내에서 "도구 평가" 및 "도구에 대한 요구 사항 형성" 기술을 발전시킬 수 있습니다.



"React를 "기술의 동물원"이라고 말하기는 어렵습니다. 이미 React 주변에는 각각의 작업 유형에 대해 2~3개의 추천 도구가 형성되어 있습니다. 프로젝트마다 그들의 조합을 변경할 수 있지만, 응용 프로그램을 구축하는 아주 기본적인 방식은 변하지 않습니다. 또한 Angular와 마찬가지로 프로젝트 구조에 빨리 익숙해질 것입니다.

합리적인 질문. "Angular가 필요한가요"? — 놀랍게도, 네요.

SPA를 위해 과거에 Angular가 제공할 수 있던 것은 아직까지 아무도 반복할 수 없었습니다.

다른 도구들보다 뒤처지고 여러 해 동안 문제를 겪음에도 불구하고, 개발자들은 강력한 솔루션을 즉시 가져오기 위해 Angular를 선택했습니다. 언제나 프로젝트에서 알고 있는 기술과 함께 작업을 해왔고, 이는 학습에 리소스를 낭비하지 않고 교차 기능 팀을 구축하는 데 도움이 되었습니다."



만약 Angular 이전에 RxJS를 사용해 보았다면, 이것은 좋은 전이 보너스가 될 것입니다. 만든 모든 애플리케이션에 RxJS를 추가할 수 없었던 이유는 팀의 승인과 사용 사유를 정당화해야 했기 때문입니다. Angular는 RxJS의 사용을 권장하며 개발을 쉽게 만들기 위한 자체 연산자를 제공합니다.

Angular로 전환하기 전에 재사용 가능한 솔루션을 개발하면서 오류 및 기술을 경험해보는 것이 좋습니다. 사용성을 느끼기 위해 Angular로 이주하기 전에 몇 가지 경험이 필요합니다.