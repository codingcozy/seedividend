---
title: "리액트 컨텍스트를 올바르게 활용하기"
description: ""
coverImage: "/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"
date: 2024-05-14 12:12
ogImage: 
  url: /assets/img/2024-05-14-UsingReactcontextstherightway_0.png
tag: Tech
originalTitle: "Using React contexts the right way"
link: "https://medium.com/@meric.emmanuel/using-react-contexts-the-right-way-10e14e10257f"
---


리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.

적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.

![이미지](/assets/img/2024-05-14-UsingReactcontextstherightway_0.png)

# 컨텍스트를 작성하는 방식의 관용적인 방법



제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.

이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.

상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.

그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.



저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.

저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.

이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:

그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:



훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.

한 가지씩 몇 가지 예시를 살펴보겠습니다.

## URL에 상태 저장하기

두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.



## 로컬 스토리지에 상태 저장하기

마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.

마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:

이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.



## 파생 상태 노출 및 사용자 정의 작업 노출하기

Provider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.

다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.

이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.



# 컨텍스트 생성을 덜 번거롭게 만들기

일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.

그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.

앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.



다음과 같이 전역 범위에서 사용할 수 있습니다:

이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 "의사 전역" 상태를 매우 쉽게 생성할 수 있습니다.

여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.

## 기타 장점



요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:

- 다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)
- 중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.
- 내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.
- 데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.

# 결론

캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.



내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.